# Include specific component assets in applications

## Problem and background

The [current method for including the components](https://github.com/alphagov/govuk_publishing_components/blob/master/docs/install-and-use.md#4-include-the-assets) in a frontend application (such as `government-frontend`) is to include `_all_components.scss` and `_all_components_print.scss` in the Sass of that application. This has some benefits:

- all components are automatically included in the application

This also has some detriments:

- all components are included regardless of whether they are used, so unused CSS may be included
- only publically facing components can be added to the gem in order to prevent the previous problem

We now have a number of non-public applications that use the components gem and components are being written for those applications. While the past model of putting components into applications has worked, we now have components that need to be shared across more than one private application, which is not possible with the current model.

## Proposed solution

Instead of including all of the component Sass each application should be configured to only include the components that it needs. For example, in an applications `_application.scss`:

```
// currently
@import 'govuk_publishing_components/all_components';
```

```
// proposed
@import 'govuk_publishing_components/components/accordion';
@import 'govuk_publishing_components/components/button';
// (etc.)
```

This would mean we can add any components we like to the gem without worrying that they are needlessly adding page weight to the publically facing GOV.UK.

## Javascript

We can do something similar with Javascript.

```
// currently
//= require govuk_publishing_components/all_components
```

```
// proposed
//= require govuk_publishing_components/components/accordion
//= require govuk_publishing_components/components/button
// (etc.)
```

## Further thoughts

### Finding which components are in use

Adding a not-in-use component into an application with this new model would be a relatively safe procedure, as the developer would notice immediately if the styles and Javascript for that component had not been included in the application. However for the process of migrating the current state to the proposed state it would be useful if we had some kind of tool that helped us to avoid leaving components unstyled/non-functional.

In the first instance we could search through the code base and write a test for that application to ensure the right assets are being included. This test would need to be kept up to date as components are added and removed.

We could also look at altering the component guide to either mark components in use or put them in a separate list. That way we could look at the component guide for an application and immediately know which components are in use and which are not.

### Caching on GOV.UK

The way that the Sass is currently included in each application makes caching ineffective. When a user lands on a page on GOV.UK, their browser downloads the CSS for that application (say `government-frontend`). This is a single file that includes custom styles from that application plus the styles from the gem. If they then navigate to a page served by another application (say `collections`) they download a new CSS file that contains the exact same styles from the gem, but because it is mixed in with the custom styles for that application, they are different files and cannot be cached.

One solution to this would be to separate out the styles from the gem into a distinct stylesheet. This would be downloaded once and then cached, and then each page on a new application would only download the (much smaller) styles from that application.

The solution above does not solve this problem, but it would potentially reduce the size of each downloaded CSS file. An optimal solution would be to continue with the current method but separate the current `@include` statement into a separate stylesheet for each application. This would add another stylesheet, but make it cachable. Unfortunately this wouldn't solve the private components problem - we'd need to have a 'public components' sass file and a 'private components' one, and include the required sass in each application.
