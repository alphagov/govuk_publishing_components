"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exec = exports.default = void 0;

var _cliCommand = _interopRequireDefault(require("@percy/cli-command"));

var common = _interopRequireWildcard(require("./common"));

var _start = _interopRequireDefault(require("./start"));

var _stop = _interopRequireDefault(require("./stop"));

var _ping = _interopRequireDefault(require("./ping"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const exec = (0, _cliCommand.default)('exec', {
  description: 'Start and stop Percy around a supplied command',
  usage: '[options] -- <command>',
  commands: [_start.default, _stop.default, _ping.default],
  flags: [...common.flags, {
    name: 'parallel',
    description: 'Marks the build as one of many parallel builds',
    parse: () => {
      var _process$env;

      return !!((_process$env = process.env).PERCY_PARALLEL_TOTAL || (_process$env.PERCY_PARALLEL_TOTAL = '-1'));
    }
  }, {
    name: 'partial',
    description: 'Marks the build as a partial build',
    parse: () => {
      var _process$env2;

      return !!((_process$env2 = process.env).PERCY_PARTIAL_BUILD || (_process$env2.PERCY_PARTIAL_BUILD = '1'));
    }
  }],
  examples: ['$0 -- echo "percy is running around this echo command"', '$0 -- yarn test'],
  loose: ['Warning: Missing command separator (--),', 'some command options may not work as expected'].join(' '),
  percy: {
    server: true
  }
}, async function* ({
  flags,
  argv,
  env,
  percy,
  log,
  exit
}) {
  let [command, ...args] = argv; // command is required

  if (!command) {
    log.error("You must supply a command to run after '--'");
    log.info('Example:');
    log.info('  $ percy exec -- npm test');
    exit(1);
  } // verify the provided command exists


  let which = await Promise.resolve().then(() => _interopRequireWildcard(require('which')));

  if (!which.sync(command, {
    nothrow: true
  })) {
    exit(127, `Command not found "${command}"`);
  } // attempt to start percy if enabled


  if (!percy) {
    log.warn('Percy is disabled');
  } else {
    try {
      yield* percy.start();
    } catch (error) {
      if (error.canceled) throw error;
      log.warn('Skipping visual tests');
      log.error(error);
    }
  } // provide SDKs with useful env vars


  env.PERCY_SERVER_ADDRESS || (env.PERCY_SERVER_ADDRESS = percy === null || percy === void 0 ? void 0 : percy.address());
  env.PERCY_LOGLEVEL || (env.PERCY_LOGLEVEL = log.loglevel()); // run the provided command

  log.info(`Running "${[command, ...args].join(' ')}"`);
  let [status, error] = yield* spawn(command, args); // stop percy if running (force stop if there is an error);

  await (percy === null || percy === void 0 ? void 0 : percy.stop(!!error)); // forward any returned status code

  if (status) exit(status, error);
}); // Spawn a command with cross-spawn and return an array containing the resulting status code along
// with any error encountered while running. Uses a generator pattern to handle interupt signals.

exports.exec = exec;

async function* spawn(cmd, args) {
  let {
    default: crossSpawn
  } = await Promise.resolve().then(() => _interopRequireWildcard(require('cross-spawn')));
  let proc, closed, error;

  try {
    proc = crossSpawn(cmd, args, {
      stdio: 'inherit'
    });
    proc.on('close', code => closed = code);
    proc.on('error', err => error = err); // run until an event is triggered

    /* eslint-disable-next-line no-unmodified-loop-condition */

    while (closed == null && error == null) {
      yield new Promise(r => setImmediate(r));
    }

    if (error) throw error;
    return [closed];
  } catch (err) {
    if (!err.signal) return [1, err];
    proc.kill(err.signal);
    return [0, err];
  }
}

var _default = exec;
exports.default = _default;