"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Network = void 0;

var _logger = _interopRequireDefault(require("@percy/logger"));

var _utils = require("./utils");

var _discovery = require("./discovery");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

var _pending = /*#__PURE__*/new WeakMap();

var _requests = /*#__PURE__*/new WeakMap();

var _intercepts = /*#__PURE__*/new WeakMap();

var _authentications = /*#__PURE__*/new WeakMap();

// The Interceptor class creates common handlers for dealing with intercepting asset requests
// for a given page using various devtools protocol events and commands.
class Network {
  constructor(page, options) {
    var _options$networkIdleT, _options$requestHeade, _options$userAgent;

    _defineProperty(this, "log", (0, _logger.default)('core:network'));

    _classPrivateFieldInitSpec(this, _pending, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _requests, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _intercepts, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _authentications, {
      writable: true,
      value: new Set()
    });

    _defineProperty(this, "_handleAuthRequired", async (session, event) => {
      var _this$authorization;

      let {
        username,
        password
      } = (_this$authorization = this.authorization) !== null && _this$authorization !== void 0 ? _this$authorization : {};
      let {
        requestId
      } = event;
      let response = 'Default';

      if (_classPrivateFieldGet(this, _authentications).has(requestId)) {
        response = 'CancelAuth';
      } else if (username || password) {
        response = 'ProvideCredentials';

        _classPrivateFieldGet(this, _authentications).add(requestId);
      }

      await session.send('Fetch.continueWithAuth', {
        requestId: event.requestId,
        authChallengeResponse: {
          response,
          username,
          password
        }
      });
    });

    _defineProperty(this, "_handleRequestPaused", async (session, event) => {
      let {
        networkId: requestId,
        requestId: interceptId,
        resourceType
      } = event;

      let pending = _classPrivateFieldGet(this, _pending).get(requestId);

      _classPrivateFieldGet(this, _pending).delete(requestId); // guard against redirects with the same requestId


      if ((pending === null || pending === void 0 ? void 0 : pending.request.url) === event.request.url && pending.request.method === event.request.method) {
        await this._handleRequest(session, { ...pending,
          resourceType,
          interceptId
        });
      } else {
        // track the session that intercepted the request
        _classPrivateFieldGet(this, _intercepts).set(requestId, { ...event,
          session
        });
      }
    });

    _defineProperty(this, "_handleRequestWillBeSent", async event => {
      let {
        requestId,
        request
      } = event; // do not handle data urls

      if (request.url.startsWith('data:')) return;

      if (this.interceptEnabled) {
        let intercept = _classPrivateFieldGet(this, _intercepts).get(requestId);

        _classPrivateFieldGet(this, _pending).set(requestId, event);

        if (intercept) {
          // handle the request with the session that intercepted it
          let {
            session,
            requestId: interceptId,
            resourceType
          } = intercept;
          await this._handleRequest(session, { ...event,
            resourceType,
            interceptId
          });

          _classPrivateFieldGet(this, _intercepts).delete(requestId);
        }
      }
    });

    _defineProperty(this, "_handleRequest", async (session, event) => {
      var _this$onRequest;

      let {
        request,
        requestId,
        interceptId,
        resourceType
      } = event;
      let redirectChain = []; // if handling a redirected request, associate the response and add to its redirect chain

      if (event.redirectResponse && _classPrivateFieldGet(this, _requests).has(requestId)) {
        let req = _classPrivateFieldGet(this, _requests).get(requestId);

        redirectChain = [...req.redirectChain, req]; // clean up interim requests

        this._forgetRequest(req, true);
      }

      request.type = resourceType;
      request.requestId = requestId;
      request.interceptId = interceptId;
      request.redirectChain = redirectChain;

      _classPrivateFieldGet(this, _requests).set(requestId, request);

      await ((_this$onRequest = this.onRequest) === null || _this$onRequest === void 0 ? void 0 : _this$onRequest.call(this, { ...request,
        // call to continue the request as-is
        continue: () => session.send('Fetch.continueRequest', {
          requestId: interceptId
        }),
        // call to respond with a specific status, content, and headers
        respond: ({
          status,
          content,
          headers
        }) => session.send('Fetch.fulfillRequest', {
          requestId: interceptId,
          responseCode: status || 200,
          body: Buffer.from(content).toString('base64'),
          responseHeaders: Object.entries(headers || {}).map(([name, value]) => {
            return {
              name: name.toLowerCase(),
              value: String(value)
            };
          })
        }),
        // call to fail or abort the request
        abort: error => session.send('Fetch.failRequest', {
          requestId: interceptId,
          // istanbul note: this check used to be necessary and might be again in the future if we
          // ever need to abort a request due to reasons other than failures
          errorReason: error ? 'Failed' :
          /* istanbul ignore next */
          'Aborted'
        })
      }));
    });

    _defineProperty(this, "_handleResponseReceived", (session, event) => {
      let {
        requestId,
        response
      } = event;

      let request = _classPrivateFieldGet(this, _requests).get(requestId);
      /* istanbul ignore if: race condition paranioa */


      if (!request) return;
      request.response = response;

      request.response.buffer = async () => {
        let result = await session.send('Network.getResponseBody', {
          requestId
        });
        return Buffer.from(result.body, result.base64Encoded ? 'base64' : 'utf8');
      };
    });

    _defineProperty(this, "_handleEventSourceMessageReceived", event => {
      let request = _classPrivateFieldGet(this, _requests).get(event.requestId);
      /* istanbul ignore else: race condition paranioa */


      if (request) this._forgetRequest(request);
    });

    _defineProperty(this, "_handleLoadingFinished", async event => {
      var _this$onRequestFinish;

      let request = _classPrivateFieldGet(this, _requests).get(event.requestId);
      /* istanbul ignore if: race condition paranioa */


      if (!request) return;
      await ((_this$onRequestFinish = this.onRequestFinished) === null || _this$onRequestFinish === void 0 ? void 0 : _this$onRequestFinish.call(this, request));

      this._forgetRequest(request);
    });

    _defineProperty(this, "_handleLoadingFailed", async event => {
      var _this$onRequestFailed;

      let request = _classPrivateFieldGet(this, _requests).get(event.requestId);
      /* istanbul ignore if: race condition paranioa */


      if (!request) return;
      request.error = event.errorText;
      await ((_this$onRequestFailed = this.onRequestFailed) === null || _this$onRequestFailed === void 0 ? void 0 : _this$onRequestFailed.call(this, request));

      this._forgetRequest(request);
    });

    this.page = page;
    this.timeout = (_options$networkIdleT = options.networkIdleTimeout) !== null && _options$networkIdleT !== void 0 ? _options$networkIdleT : 100;
    this.authorization = options.authorization;
    this.requestHeaders = (_options$requestHeade = options.requestHeaders) !== null && _options$requestHeade !== void 0 ? _options$requestHeade : {};
    this.userAgent = (_options$userAgent = options.userAgent) !== null && _options$userAgent !== void 0 ? _options$userAgent : // by default, emulate a non-headless browser
    page.session.browser.version.userAgent.replace('Headless', '');
    this.interceptEnabled = !!options.intercept;
    this.meta = options.meta;

    if (this.interceptEnabled) {
      this.onRequest = (0, _discovery.createRequestHandler)(this, options.intercept);
      this.onRequestFinished = (0, _discovery.createRequestFinishedHandler)(this, options.intercept);
      this.onRequestFailed = (0, _discovery.createRequestFailedHandler)(this, options.intercept);
    }
  }

  watch(session) {
    session.on('Network.requestWillBeSent', this._handleRequestWillBeSent);
    session.on('Network.responseReceived', this._handleResponseReceived.bind(this, session));
    session.on('Network.eventSourceMessageReceived', this._handleEventSourceMessageReceived);
    session.on('Network.loadingFinished', this._handleLoadingFinished);
    session.on('Network.loadingFailed', this._handleLoadingFailed);
    let commands = [session.send('Network.enable'), session.send('Network.setBypassServiceWorker', {
      bypass: true
    }), session.send('Network.setCacheDisabled', {
      cacheDisabled: true
    }), session.send('Network.setUserAgentOverride', {
      userAgent: this.userAgent
    }), session.send('Network.setExtraHTTPHeaders', {
      headers: this.requestHeaders
    })];

    if (this.interceptEnabled && session.isDocument) {
      session.on('Fetch.requestPaused', this._handleRequestPaused.bind(this, session));
      session.on('Fetch.authRequired', this._handleAuthRequired.bind(this, session));
      commands.push(session.send('Fetch.enable', {
        handleAuthRequests: true,
        patterns: [{
          urlPattern: '*'
        }]
      }));
    }

    return Promise.all(commands);
  } // Resolves after the timeout when there are no more in-flight requests.


  async idle(filter = () => true, timeout = this.timeout) {
    let requests = [];
    this.log.debug(`Wait for ${timeout}ms idle`, this.meta);
    await (0, _utils.waitFor)(() => {
      if (this.page.session.closedReason) {
        throw new Error(`Network error: ${this.page.session.closedReason}`);
      }

      requests = Array.from(_classPrivateFieldGet(this, _requests).values()).filter(filter);
      return requests.length === 0;
    }, {
      timeout: Network.TIMEOUT,
      idle: timeout
    }).catch(error => {
      // throw a better timeout error
      if (error.message.startsWith('Timeout')) {
        let msg = 'Timed out waiting for network requests to idle.';

        if (this.log.shouldLog('debug')) {
          msg += `\n\n  ${['Active requests:', ...requests.map(r => r.url)].join('\n  - ')}\n`;
        }

        throw new Error(msg);
      } else {
        throw error;
      }
    });
  } // Called when a request should be removed from various trackers


  _forgetRequest({
    requestId,
    interceptId
  }, keepPending) {
    _classPrivateFieldGet(this, _requests).delete(requestId);

    _classPrivateFieldGet(this, _authentications).delete(interceptId);

    if (!keepPending) {
      _classPrivateFieldGet(this, _pending).delete(requestId);

      _classPrivateFieldGet(this, _intercepts).delete(requestId);
    }
  } // Called when a request requires authentication. Responds to the auth request with any
  // provided authorization credentials.


}

exports.Network = Network;

_defineProperty(Network, "TIMEOUT", 30000);

var _default = Network;
exports.default = _default;