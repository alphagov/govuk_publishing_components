function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
import { yieldFor, generatePromise, AbortController } from './utils.js';

// Assigns a deffered promise and resolve & reject functions to an object
function deferred(obj) {
  return Object.assign(obj, {
    deferred: new Promise((resolve, reject) => {
      Object.assign(obj, {
        resolve,
        reject
      });
    })
  });
}

// Returns the position of a needle within a haystack, or undefined if not found
function positionOf(haystack, needle, i = 1) {
  for (let item of haystack) {
    if (item !== needle) i++;else return i;
  }
}

// Thrown when attempting to push to a closed queue
class QueueClosedError extends Error {
  name = this.constructor.name;
}

// A queue instance keeps a list of arbitrary items to process concurrently,
// configured and controlled by various methods
var _handlers = /*#__PURE__*/new WeakMap();
var _queued = /*#__PURE__*/new WeakMap();
var _pending = /*#__PURE__*/new WeakMap();
var _dequeue = /*#__PURE__*/new WeakSet();
var _find = /*#__PURE__*/new WeakSet();
var _start = /*#__PURE__*/new WeakMap();
var _end = /*#__PURE__*/new WeakMap();
var _process = /*#__PURE__*/new WeakSet();
var _until = /*#__PURE__*/new WeakSet();
export class Queue {
  constructor() {
    _classPrivateMethodInitSpec(this, _until);
    _classPrivateMethodInitSpec(this, _process);
    _classPrivateMethodInitSpec(this, _find);
    _classPrivateMethodInitSpec(this, _dequeue);
    _defineProperty(this, "concurrency", 10);
    _classPrivateFieldInitSpec(this, _handlers, {
      writable: true,
      value: {}
    });
    _classPrivateFieldInitSpec(this, _queued, {
      writable: true,
      value: new Set()
    });
    _classPrivateFieldInitSpec(this, _pending, {
      writable: true,
      value: new Set()
    });
    _classPrivateFieldInitSpec(this, _start, {
      writable: true,
      value: null
    });
    _classPrivateFieldInitSpec(this, _end, {
      writable: true,
      value: null
    });
    _defineProperty(this, "readyState", 0);
  }
  // Configure queue properties
  set({
    concurrency
  }) {
    if (concurrency) this.concurrency = concurrency;
    return this;
  }

  // Configure queue handlers

  handle(event, handler) {
    _classPrivateFieldGet(this, _handlers)[event] = handler;
    return this;
  }

  // internal queues

  // Queue size is total queued and pending items
  get size() {
    return _classPrivateFieldGet(this, _queued).size + _classPrivateFieldGet(this, _pending).size;
  }

  // Pushes an item into the queue, additional args are passed to any configured task handler.
  push(item, ...args) {
    let task = deferred({
      item
    });

    // attach any configured error handler
    task.deferred = task.deferred.catch(e => {
      if (!_classPrivateFieldGet(this, _handlers).error) throw e;
      return _classPrivateFieldGet(this, _handlers).error(item, e);
    });

    // when closed, reject with a queue closed error
    if (this.readyState > 2) {
      task.reject(new QueueClosedError());
      return task.deferred;
    }

    // call or set up other handlers
    let exists = this.cancel(item);
    task.item = item = _classPrivateFieldGet(this, _handlers).push ? _classPrivateFieldGet(this, _handlers).push(item, exists) : item;
    task.handler = () => _classPrivateFieldGet(this, _handlers).task ? _classPrivateFieldGet(this, _handlers).task(item, ...args) : item;
    task.ctrl = new AbortController();

    // queue this task & maybe dequeue the next task
    _classPrivateFieldGet(this, _queued).add(task);
    _classPrivateMethodGet(this, _dequeue, _dequeue2).call(this);

    // return the deferred task promise
    return task.deferred;
  }

  // Maybe processes the next queued item task.

  // Cancels and aborts a specific item task.
  cancel(item) {
    let task = _classPrivateMethodGet(this, _find, _find2).call(this, item);
    task === null || task === void 0 ? void 0 : task.ctrl.abort();
    let queued = _classPrivateFieldGet(this, _queued).delete(task);
    let pending = _classPrivateFieldGet(this, _pending).delete(task);

    // reject queued tasks that are not pending
    if (task && queued && !pending) {
      task.reject(task.ctrl.signal.reason);
    }

    // return the cancelled item
    return task === null || task === void 0 ? void 0 : task.item;
  }

  // Returns an item task matching the provided subject.

  // Initialize a starting task or return an existing one.
  start() {
    var _classPrivateFieldGet2;
    _classPrivateFieldGet(this, _start) ?? _classPrivateFieldSet(this, _start, deferred({
      readyState: 1
    }));
    (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _start)).handler ?? (_classPrivateFieldGet2.handler = _classPrivateFieldGet(this, _end) // wait for any ending task to complete first
    ? () => _classPrivateFieldGet(this, _end).promise.then(_classPrivateFieldGet(this, _handlers).start) : _classPrivateFieldGet(this, _handlers).start);
    return _classPrivateMethodGet(this, _process, _process2).call(this, _classPrivateFieldGet(this, _start)).deferred;
  }

  // intialize an ending task or return an existing one
  end() {
    var _classPrivateFieldGet3;
    _classPrivateFieldGet(this, _end) ?? _classPrivateFieldSet(this, _end, deferred({
      readyState: 0
    }));
    (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _end)).handler ?? (_classPrivateFieldGet3.handler = _classPrivateFieldGet(this, _start) // wait for any starting task to complete first
    ? () => _classPrivateFieldGet(this, _start).promise.then(_classPrivateFieldGet(this, _handlers).end) : _classPrivateFieldGet(this, _handlers).end);
    return _classPrivateMethodGet(this, _process, _process2).call(this, _classPrivateFieldGet(this, _end)).deferred;
  }

  // represents various queue states such as ready, running, or closed

  // run the queue, starting it if necessary, and start dequeuing tasks
  run() {
    if (!_classPrivateFieldGet(this, _start)) this.start();
    // when starting, state is updated afterwards
    if (this.readyState === 0) _classPrivateFieldGet(this, _start).readyState = 2;
    if (this.readyState === 1) this.readyState = 2;
    while (_classPrivateMethodGet(this, _dequeue, _dequeue2).call(this)) _classPrivateMethodGet(this, _dequeue, _dequeue2).call(this);
    return this;
  }

  // stop a running queue
  stop() {
    if (this.readyState === 2) this.readyState = 1;
    return this;
  }

  // close a running queue, optionally aborting it
  close(abort) {
    var _classPrivateFieldGet4;
    // when starting, state is updated afterwards
    if ((_classPrivateFieldGet4 = _classPrivateFieldGet(this, _start)) !== null && _classPrivateFieldGet4 !== void 0 && _classPrivateFieldGet4.pending) _classPrivateFieldGet(this, _start).readyState = 3;
    if (this.readyState < 3) this.readyState = 3;
    if (abort) this.clear();
    return this;
  }

  // clear and abort any queued tasks
  clear() {
    let tasks = [..._classPrivateFieldGet(this, _queued)];
    _classPrivateFieldGet(this, _queued).clear();
    for (let task of tasks) {
      task.ctrl.abort();
      task.reject(task.ctrl.signal.reason);
    }
  }

  // process a single item task when started
  process(item) {
    var _classPrivateFieldGet5;
    let task = _classPrivateMethodGet(this, _find, _find2).call(this, item);
    if (task && !_classPrivateFieldGet(this, _start)) this.start();
    (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _start)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.promise.then(() => _classPrivateMethodGet(this, _process, _process2).call(this, task));
    return task === null || task === void 0 ? void 0 : task.deferred;
  }

  // processes tasks using a generator promise, allowing task handlers to be cancelable

  // returns a generator that yeilds until started and no longer pending, calling the
  // callback every 10ms during checks with the current number of pending tasks
  idle(callback) {
    return yieldFor(() => {
      var _classPrivateFieldGet6;
      callback === null || callback === void 0 ? void 0 : callback(_classPrivateFieldGet(this, _pending).size);
      let starting = ((_classPrivateFieldGet6 = _classPrivateFieldGet(this, _start)) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.pending) === true;
      return !starting && !_classPrivateFieldGet(this, _pending).size;
    }, {
      idle: 10
    });
  }

  // process items up to the latest queued item, starting the queue if necessary;
  // returns a generator that yields until the flushed item has finished processing
  flush(callback) {
    let interrupt =
    // check for existing interrupts
    [..._classPrivateFieldGet(this, _pending)].find(t => t.stop) ?? [..._classPrivateFieldGet(this, _queued)].find(t => t.stop);

    // get the latest queued or pending task to track
    let flush = [..._classPrivateFieldGet(this, _queued)].pop() ?? [..._classPrivateFieldGet(this, _pending)].pop();
    // determine if the queue should be stopped after flushing
    if (flush) flush.stop = (interrupt === null || interrupt === void 0 ? void 0 : interrupt.stop) ?? this.readyState < 2;
    // remove the old interrupt to avoid stopping early
    if (interrupt) delete interrupt.stop;
    // start the queue if not started
    if (!_classPrivateFieldGet(this, _start)) this.start();
    // run the queue if stopped
    if (flush !== null && flush !== void 0 && flush.stop) this.run();

    // will yield with the callback until done flushing
    return _classPrivateMethodGet(this, _until, _until2).call(this, flush, callback);
  }

  // Repeatedly yields, calling the callback with the position of the task within the queue
}
function _dequeue2() {
  if (!_classPrivateFieldGet(this, _queued).size || this.readyState < 2) return;
  if (_classPrivateFieldGet(this, _pending).size >= this.concurrency) return;
  let [task] = _classPrivateFieldGet(this, _queued);
  return _classPrivateMethodGet(this, _process, _process2).call(this, task);
}
function _find2(subject) {
  let find = _classPrivateFieldGet(this, _handlers).find
  // use any configured find handler to match items
  ? ({
    item
  }) => _classPrivateFieldGet(this, _handlers).find(subject, item) : ({
    item
  }) => subject === item;
  return (
    // look at queued then pending items
    [..._classPrivateFieldGet(this, _queued)].find(find) ?? [..._classPrivateFieldGet(this, _pending)].find(find)
  );
}
function _process2(task) {
  var _task$ctrl;
  if (!task || task.promise) return task;
  let queued = _classPrivateFieldGet(this, _queued).has(task);
  // remove queued tasks from the queue
  if (queued) _classPrivateFieldGet(this, _queued).delete(task);
  // clear queued tasks when ending
  if (task === _classPrivateFieldGet(this, _end)) this.clear();
  // add queued tasks to pending queue
  if (queued) _classPrivateFieldGet(this, _pending).add(task);
  // stop the queue when necessary
  if (task.stop) this.stop();
  // mark task as pending
  task.pending = true;

  // handle the task using a generator promise
  task.promise = generatePromise(task.handler, (_task$ctrl = task.ctrl) === null || _task$ctrl === void 0 ? void 0 : _task$ctrl.signal, (err, val) => {
    // clean up pending tasks that have not been aborted
    if (queued && !task.ctrl.signal.aborted) _classPrivateFieldGet(this, _pending).delete(task);
    // update queue state when necessary
    if (task.readyState != null) this.readyState = task.readyState;
    // clean up internal tasks after ending
    if (!this.readyState) _classPrivateFieldSet(this, _start, _classPrivateFieldSet(this, _end, null));
    // resolve or reject the deferred task promise
    task[err ? 'reject' : 'resolve'](err ?? val);
    // keep dequeuing when running
    if (this.readyState === 2) this.run();
    // mark pending task done
    task.pending = false;
  });
  return task;
}
async function* _until2(task, callback) {
  try {
    yield* yieldFor(() => {
      var _classPrivateFieldGet7;
      if ((_classPrivateFieldGet7 = _classPrivateFieldGet(this, _start)) !== null && _classPrivateFieldGet7 !== void 0 && _classPrivateFieldGet7.pending) return false;
      let queued,
        pending = _classPrivateFieldGet(this, _pending).size;
      // calculate the position within queued when not pending
      if (task && task.pending == null) queued = positionOf(_classPrivateFieldGet(this, _queued), task);
      // calculate the position within pending when not stopping
      if (!(task !== null && task !== void 0 && task.stop) && (task === null || task === void 0 ? void 0 : task.pending) != null) pending = positionOf(_classPrivateFieldGet(this, _pending), task);
      // call the callback and return true when not queued or pending
      let position = (queued ?? 0) + (pending ?? 0);
      callback === null || callback === void 0 ? void 0 : callback(position);
      return !position;
    }, {
      idle: 10
    });
  } catch (err) {
    // reset flushed tasks on error
    if (task.stop) this.stop();
    delete task.stop;
    throw err;
  }
}
export default Queue;