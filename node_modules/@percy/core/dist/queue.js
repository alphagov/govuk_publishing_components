"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Queue = void 0;

var _utils = require("./utils");

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

var _queued = /*#__PURE__*/new WeakMap();

var _pending = /*#__PURE__*/new WeakMap();

class Queue {
  constructor(concurrency = 10) {
    _defineProperty(this, "running", true);

    _defineProperty(this, "closed", false);

    _classPrivateFieldInitSpec(this, _queued, {
      writable: true,
      value: new Map()
    });

    _classPrivateFieldInitSpec(this, _pending, {
      writable: true,
      value: new Map()
    });

    this.concurrency = concurrency;
  }

  push(id, callback, priority) {
    if (this.closed && !id.startsWith('@@/')) {
      throw new Error('Closed');
    }

    this.cancel(id);
    let task = {
      id,
      callback,
      priority
    };
    task.promise = new Promise((resolve, reject) => {
      Object.assign(task, {
        resolve,
        reject
      });

      _classPrivateFieldGet(this, _queued).set(id, task);

      this._dequeue();
    });
    return task.promise;
  }

  cancel(id) {
    var _classPrivateFieldGet2, _classPrivateFieldGet3;

    (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _pending).get(id)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : (_classPrivateFieldGet3 = _classPrivateFieldGet2.cancel) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.call(_classPrivateFieldGet2);

    _classPrivateFieldGet(this, _pending).delete(id);

    _classPrivateFieldGet(this, _queued).delete(id);
  }

  has(id) {
    return _classPrivateFieldGet(this, _queued).has(id) || _classPrivateFieldGet(this, _pending).has(id);
  }

  clear() {
    _classPrivateFieldGet(this, _queued).clear();

    return this.size;
  }

  get size() {
    return _classPrivateFieldGet(this, _queued).size + _classPrivateFieldGet(this, _pending).size;
  }

  run() {
    this.running = true;

    while (this.running && _classPrivateFieldGet(this, _queued).size && _classPrivateFieldGet(this, _pending).size < this.concurrency) this._dequeue();

    return this;
  }

  stop() {
    this.running = false;
    return this;
  }

  open() {
    this.closed = false;
    return this;
  }

  close(abort) {
    if (abort) this.stop().clear();
    this.closed = true;
    return this;
  }

  idle(callback) {
    return (0, _utils.waitFor)(() => {
      callback === null || callback === void 0 ? void 0 : callback(_classPrivateFieldGet(this, _pending).size);
      return !_classPrivateFieldGet(this, _pending).size;
    }, {
      idle: 10
    });
  }

  empty(callback) {
    return (0, _utils.waitFor)(() => {
      callback === null || callback === void 0 ? void 0 : callback(this.size);
      return !this.size;
    }, {
      idle: 10
    });
  }

  flush(callback) {
    let stopped = !this.running;
    this.run().push('@@/flush', () => {
      if (stopped) this.stop();
    });
    return this.idle(pend => {
      let left = [..._classPrivateFieldGet(this, _queued).keys()].indexOf('@@/flush');
      if (!~left && !_classPrivateFieldGet(this, _pending).has('@@/flush')) left = 0;
      callback === null || callback === void 0 ? void 0 : callback(pend + left);
    }).canceled(() => {
      if (stopped) this.stop();
      this.cancel('@@/flush');
    });
  }

  next() {
    let next;

    for (let [id, task] of _classPrivateFieldGet(this, _queued)) {
      if (!next || task.priority != null && next.priority == null || task.priority < next.priority) next = task;
      if (id === '@@/flush') break;
    }

    return next;
  }

  _dequeue() {
    if (!this.running) return;
    if (_classPrivateFieldGet(this, _pending).size >= this.concurrency) return;
    let task = this.next();
    if (!task) return;

    _classPrivateFieldGet(this, _queued).delete(task.id);

    _classPrivateFieldGet(this, _pending).set(task.id, task);

    let done = callback => arg => {
      var _task$cancel;

      if (!((_task$cancel = task.cancel) !== null && _task$cancel !== void 0 && _task$cancel.triggered)) {
        _classPrivateFieldGet(this, _pending).delete(task.id);
      }

      callback(arg);

      this._dequeue();
    };

    try {
      let gen = (0, _utils.generatePromise)(task.callback);
      task.cancel = gen.cancel;
      return gen.then(done(task.resolve), done(task.reject));
    } catch (err) {
      done(task.reject)(err);
    }
  }

}

exports.Queue = Queue;
var _default = Queue;
exports.default = _default;