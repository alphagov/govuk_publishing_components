"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Session = void 0;

var _events = _interopRequireDefault(require("events"));

var _logger = _interopRequireDefault(require("@percy/logger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

var _callbacks = /*#__PURE__*/new WeakMap();

class Session extends _events.default {
  constructor(browser, {
    params,
    sessionId: parentId
  }) {
    var _this$parent;

    super();

    _classPrivateFieldInitSpec(this, _callbacks, {
      writable: true,
      value: new Map()
    });

    _defineProperty(this, "log", (0, _logger.default)('core:session'));

    _defineProperty(this, "children", new Map());

    _defineProperty(this, "_handleTargetCrashed", () => {
      this.closedReason = 'Session crashed!';
      this.close();
    });

    _defineProperty(this, "_handleClosedError", error => {
      if (!error.message.endsWith(this.closedReason)) {
        this.log.debug(error, this.meta);
      }
    });

    this.browser = browser;
    this.sessionId = params.sessionId;
    this.targetId = params.targetInfo.targetId;
    this.type = params.targetInfo.type;
    this.isDocument = this.type === 'page' || this.type === 'iframe';
    this.parent = browser.sessions.get(parentId);
    (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.set(this.sessionId, this);
    this.on('Inspector.targetCrashed', this._handleTargetCrashed);
  }

  async close() {
    if (!this.browser) return;
    await this.browser.send('Target.closeTarget', {
      targetId: this.targetId
    }).catch(this._handleClosedError);
  }

  async send(method, params) {
    /* istanbul ignore next: race condition paranoia */
    if (this.closedReason) {
      throw new Error(`Protocol error (${method}): ${this.closedReason}`);
    } // send a raw message to the browser so we can provide a sessionId


    let id = await this.browser.send({
      sessionId: this.sessionId,
      method,
      params
    }); // will resolve or reject when a matching response is received

    return new Promise((resolve, reject) => {
      _classPrivateFieldGet(this, _callbacks).set(id, {
        error: new Error(),
        resolve,
        reject,
        method
      });
    });
  }

  _handleMessage(data) {
    if (data.id && _classPrivateFieldGet(this, _callbacks).has(data.id)) {
      // resolve or reject a pending promise created with #send()
      let callback = _classPrivateFieldGet(this, _callbacks).get(data.id);

      _classPrivateFieldGet(this, _callbacks).delete(data.id);
      /* istanbul ignore next: races with browser._handleMessage() */


      if (data.error) {
        callback.reject(Object.assign(callback.error, {
          message: `Protocol error (${callback.method}): ${data.error.message}` + ('data' in data.error ? `: ${data.error.data}` : '')
        }));
      } else {
        callback.resolve(data.result);
      }
    } else {
      // emit the message as an event
      this.emit(data.method, data.params);
    }
  }

  _handleClose() {
    var _this$parent2;

    this.closedReason || (this.closedReason = 'Session closed.'); // reject any pending callbacks

    for (let callback of _classPrivateFieldGet(this, _callbacks).values()) {
      callback.reject(Object.assign(callback.error, {
        message: `Protocol error (${callback.method}): ${this.closedReason}`
      }));
    }

    _classPrivateFieldGet(this, _callbacks).clear();

    (_this$parent2 = this.parent) === null || _this$parent2 === void 0 ? void 0 : _this$parent2.children.delete(this.sessionId);
    this.browser = null;
  }

}

exports.Session = Session;
var _default = Session;
exports.default = _default;