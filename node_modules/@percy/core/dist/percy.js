"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Percy = void 0;

var _client = _interopRequireDefault(require("@percy/client"));

var _config = _interopRequireDefault(require("@percy/config"));

var _utils = require("@percy/config/dist/utils");

var _logger = _interopRequireDefault(require("@percy/logger"));

var _queue = _interopRequireDefault(require("./queue"));

var _browser = _interopRequireDefault(require("./browser"));

var _server = _interopRequireDefault(require("./server"));

var _snapshot = require("./snapshot");

var _utils2 = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

var _uploads = /*#__PURE__*/new WeakMap();

var _snapshots = /*#__PURE__*/new WeakMap();

// A Percy instance will create a new build when started, handle snapshot
// creation, asset discovery, and resource uploads, and will finalize the build
// when stopped. Snapshots are processed concurrently and the build is not
// finalized until all snapshots have been handled.
class Percy {
  // Static shortcut to create and start an instance in one call
  static async start(options) {
    let instance = new this(options);
    await instance.start();
    return instance;
  }

  constructor({
    // initial log level
    loglevel,
    // do not eagerly upload snapshots
    deferUploads,
    // run without uploading anything
    skipUploads,
    // implies `skipUploads` and also skips asset discovery
    dryRun,
    // configuration filepath
    config,
    // provided to @percy/client
    token,
    clientInfo = '',
    environmentInfo = '',
    // snapshot server options
    server = true,
    port = 5338,
    // options such as `snapshot` and `discovery` that are valid Percy config
    // options which will become accessible via the `.config` property
    ..._options
  } = {}) {
    _defineProperty(this, "log", (0, _logger.default)('core'));

    _defineProperty(this, "readyState", null);

    _classPrivateFieldInitSpec(this, _uploads, {
      writable: true,
      value: new _queue.default()
    });

    _classPrivateFieldInitSpec(this, _snapshots, {
      writable: true,
      value: new _queue.default()
    });

    _defineProperty(this, "idle", () => (0, _utils2.generatePromise)(async function* () {
      yield* _classPrivateFieldGet(this, _snapshots).idle();
      yield* _classPrivateFieldGet(this, _uploads).idle();
    }.bind(this)));

    _defineProperty(this, "start", options => (0, _utils2.generatePromise)(async function* () {
      // already starting or started
      if (this.readyState != null) return;
      this.readyState = 0; // create a percy build as the first immediately queued task

      let buildTask = _classPrivateFieldGet(this, _uploads).push('build/create', () => {
        // pause other queued tasks until after the build is created
        _classPrivateFieldGet(this, _uploads).stop();

        return this.client.createBuild().then(({
          data: {
            id,
            attributes
          }
        }) => {
          this.build = {
            id
          };
          this.build.number = attributes['build-number'];
          this.build.url = attributes['web-url'];

          _classPrivateFieldGet(this, _uploads).run();
        });
      }, 0); // handle deferred build errors


      if (this.deferUploads) {
        buildTask.catch(err => {
          this.log.error('Failed to create build');
          this.log.error(err);
          this.close();
        });
      }

      try {
        var _this$server;

        // when not deferred, wait until the build is created first
        if (!this.deferUploads) await buildTask; // maybe launch the discovery browser

        if (!this.dryRun && (options === null || options === void 0 ? void 0 : options.browser) !== false) {
          yield this.browser.launch();
        } // start the server after everything else is ready


        yield (_this$server = this.server) === null || _this$server === void 0 ? void 0 : _this$server.listen(this.port); // mark instance as started

        this.log.info('Percy has started!');
        this.readyState = 1;
      } catch (error) {
        var _this$server2;

        // on error, close any running server and browser
        await ((_this$server2 = this.server) === null || _this$server2 === void 0 ? void 0 : _this$server2.close());
        await this.browser.close(); // mark instance as closed

        this.readyState = 3; // when uploads are deferred, cancel build creation

        if (error.canceled && this.deferUploads) {
          _classPrivateFieldGet(this, _uploads).cancel('build/create');

          this.readyState = null;
        } // throw an easier-to-understand error when the port is taken


        if (error.code === 'EADDRINUSE') {
          throw new Error('Percy is already running or the port is in use');
        } else {
          throw error;
        }
      }
    }.bind(this)));

    _defineProperty(this, "flush", close => (0, _utils2.generatePromise)(async function* () {
      // close the snapshot queue and wait for it to empty
      if (_classPrivateFieldGet(this, _snapshots).size) {
        if (close) _classPrivateFieldGet(this, _snapshots).close();
        yield* _classPrivateFieldGet(this, _snapshots).flush(s => {
          // do not log a count when not closing or while dry-running
          if (!close || this.dryRun) return;
          this.log.progress(`Processing ${s} snapshot${s !== 1 ? 's' : ''}...`, !!s);
        });
      } // run, close, and wait for the upload queue to empty


      if (!this.skipUploads && _classPrivateFieldGet(this, _uploads).size) {
        if (close) _classPrivateFieldGet(this, _uploads).close();
        yield* _classPrivateFieldGet(this, _uploads).flush(s => {
          // do not log a count when not closing or while creating a build
          if (!close || _classPrivateFieldGet(this, _uploads).has('build/create')) return;
          this.log.progress(`Uploading ${s} snapshot${s !== 1 ? 's' : ''}...`, !!s);
        });
      }
    }.bind(this)).canceled(() => {
      // reopen closed queues when canceled
      _classPrivateFieldGet(this, _snapshots).open();

      _classPrivateFieldGet(this, _uploads).open();
    }));

    _defineProperty(this, "stop", force => (0, _utils2.generatePromise)(async function* () {
      var _this$server3, _this$build;

      // not started, but the browser was launched
      if (!this.readyState && this.browser.isConnected()) {
        await this.browser.close();
      } // not started or already stopped


      if (!this.readyState || this.readyState > 2) return; // close queues asap

      if (force) this.close(); // already stopping

      if (this.readyState === 2) return;
      this.readyState = 2; // log when force stopping

      if (force) this.log.info('Stopping percy...'); // process uploads and close queues

      yield* this.flush(true); // if dry-running, log the total number of snapshots

      if (this.dryRun && _classPrivateFieldGet(this, _uploads).size) {
        let total = _classPrivateFieldGet(this, _uploads).size - 1; // subtract the build task

        this.log.info(`Found ${total} snapshot${total !== 1 ? 's' : ''}`);
      } // close any running server and browser


      await ((_this$server3 = this.server) === null || _this$server3 === void 0 ? void 0 : _this$server3.close());
      await this.browser.close(); // finalize and log build info

      let meta = {
        build: this.build
      };

      if ((_this$build = this.build) !== null && _this$build !== void 0 && _this$build.failed) {
        // do not finalize failed builds
        this.log.warn(`Build #${this.build.number} failed: ${this.build.url}`, meta);
      } else if (this.build) {
        // finalize the build
        await this.client.finalizeBuild(this.build.id);
        this.log.info(`Finalized build #${this.build.number}: ${this.build.url}`, meta);
      } else {
        // no build was ever created (likely failed while deferred)
        this.log.warn('Build not created', meta);
      } // mark instance as stopped


      this.readyState = 3;
    }.bind(this)).canceled(() => {
      // reset ready state when canceled
      this.readyState = 1;
    }));

    if (loglevel) this.loglevel(loglevel);
    this.dryRun = !!dryRun;
    this.skipUploads = this.dryRun || !!skipUploads;
    this.deferUploads = this.skipUploads || !!deferUploads;
    if (this.deferUploads) _classPrivateFieldGet(this, _uploads).stop();
    this.config = _config.default.load({
      overrides: _options,
      path: config
    });

    if (this.config.discovery.concurrency) {
      let {
        concurrency
      } = this.config.discovery;
      _classPrivateFieldGet(this, _uploads).concurrency = concurrency;
      _classPrivateFieldGet(this, _snapshots).concurrency = concurrency;
    }

    this.client = new _client.default({
      token,
      clientInfo,
      environmentInfo
    });
    this.browser = new _browser.default({ ...this.config.discovery.launchOptions,
      cookies: this.config.discovery.cookies
    });

    if (server) {
      this.server = (0, _server.default)(this);
      this.port = port;
    }
  } // Shortcut for controlling the global logger's log level.


  loglevel(level) {
    return _logger.default.loglevel(level);
  } // Snapshot server API address


  address() {
    return `http://localhost:${this.port}`;
  } // Set client & environment info, and override loaded config options


  setConfig({
    clientInfo,
    environmentInfo,
    ...config
  }) {
    this.client.addClientInfo(clientInfo);
    this.client.addEnvironmentInfo(environmentInfo); // normalize config and do nothing if empty

    config = _config.default.normalize(config, {
      schema: '/config'
    });
    if (!config) return this.config; // validate provided config options

    let errors = _config.default.validate(config);

    if (errors) {
      this.log.warn('Invalid config:');

      for (let e of errors) this.log.warn(`- ${e.path}: ${e.message}`);
    } // merge and override existing config options


    this.config = (0, _utils.merge)([this.config, config], (path, prev, next) => {
      // replace arrays instead of merging
      return Array.isArray(next) && [path, next];
    }); // adjust concurrency if necessary

    if (this.config.discovery.concurrency) {
      let {
        concurrency
      } = this.config.discovery;
      _classPrivateFieldGet(this, _uploads).concurrency = concurrency;
      _classPrivateFieldGet(this, _snapshots).concurrency = concurrency;
    }

    return this.config;
  } // Resolves once snapshot and upload queues are idle


  // Immediately stops all queues, preventing any more tasks from running
  close() {
    _classPrivateFieldGet(this, _snapshots).close(true);

    _classPrivateFieldGet(this, _uploads).close(true);
  } // Starts a local API server, a browser process, and queues creating a new Percy build which will run
  // at a later time when uploads are deferred, or run immediately when not deferred.


  // Deprecated capture method
  capture(options) {
    this.log.deprecated('The #capture() method will be ' + 'removed in 1.0.0. Use #snapshot() instead.');
    return this.snapshot(options);
  } // Takes one or more snapshots of a page while discovering resources to upload with the
  // snapshot. If an existing dom snapshot is provided, it will be served as the root resource
  // during asset discovery. Once asset discovery has completed, the queued snapshot will resolve
  // and an upload task will be queued separately.


  snapshot(options) {
    if (this.readyState !== 1) {
      throw new Error('Not running');
    } // handle multiple snapshots


    if (Array.isArray(options)) {
      return Promise.all(options.map(o => this.snapshot(o)));
    } // get derived snapshot config options


    let snapshot = (0, _snapshot.getSnapshotConfig)(this, options); // clear any existing snapshot uploads of the same name (for retries)

    for (let {
      name
    } of [snapshot, ...(snapshot.additionalSnapshots || [])]) {
      _classPrivateFieldGet(this, _uploads).cancel(`upload/${name}`);
    } // resolves after asset discovery has finished and uploads have been queued


    return _classPrivateFieldGet(this, _snapshots).push(`snapshot/${snapshot.name}`, async function* () {
      try {
        yield* (0, _snapshot.discoverSnapshotResources)(this, snapshot, (snap, resources) => {
          if (!this.dryRun) this.log.info(`Snapshot taken: ${snap.name}`, snap.meta);

          this._scheduleUpload(snap.name, { ...snap,
            resources
          });
        });
      } catch (error) {
        if (error.canceled) {
          this.log.error('Received a duplicate snapshot name, ' + `the previous snapshot was canceled: ${snapshot.name}`);
        } else {
          this.log.error(`Encountered an error taking snapshot: ${snapshot.name}`, snapshot.meta);
          this.log.error(error, snapshot.meta);
        }
      } // fixes an issue in Node 12 where implicit returns do not correctly resolve the async
      // generator objects â€” https://crbug.com/v8/10238


      return; // eslint-disable-line no-useless-return
    }.bind(this));
  } // Queues a snapshot upload with the provided options


  _scheduleUpload(name, options) {
    return _classPrivateFieldGet(this, _uploads).push(`upload/${name}`, async () => {
      try {
        /* istanbul ignore if: useful for other internal packages */
        if (typeof options === 'function') options = await options();
        await this.client.sendSnapshot(this.build.id, options);
      } catch (error) {
        var _error$response, _failed$detail;

        let failed = ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 422 && error.response.body.errors.find(e => {
          var _e$source;

          return ((_e$source = e.source) === null || _e$source === void 0 ? void 0 : _e$source.pointer) === '/data/attributes/build';
        });
        this.log.error(`Encountered an error uploading snapshot: ${name}`, options.meta);
        this.log.error((_failed$detail = failed === null || failed === void 0 ? void 0 : failed.detail) !== null && _failed$detail !== void 0 ? _failed$detail : error, options.meta); // build failed at some point, stop accepting snapshots

        if (failed) {
          this.build.failed = true;
          this.close();
        }
      }
    });
  }

}

exports.Percy = Percy;
var _default = Percy;
exports.default = _default;