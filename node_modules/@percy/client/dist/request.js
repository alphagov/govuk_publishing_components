"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ProxyHttpsAgent = exports.ProxyHttpAgent = void 0;
exports.getProxy = getProxy;
exports.href = href;
exports.port = port;
exports.proxyAgentFor = proxyAgentFor;
exports.request = request;

var _net = _interopRequireDefault(require("net"));

var _tls = _interopRequireDefault(require("tls"));

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _logger = _interopRequireDefault(require("@percy/logger"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const CRLF = '\r\n';
const STATUS_REG = /^HTTP\/1.[01] (\d*)/;
const RETRY_ERROR_CODES = ['ECONNREFUSED', 'ECONNRESET', 'EPIPE', 'EHOSTUNREACH', 'EAI_AGAIN']; // Returns the port number of a URL object. Defaults to port 443 for https
// protocols or port 80 otherwise.

function port(options) {
  if (options.port) return options.port;
  return options.protocol === 'https:' ? 443 : 80;
}

function href(options) {
  let {
    protocol,
    hostname,
    path,
    pathname,
    search,
    hash
  } = options;
  return `${protocol}//${hostname}:${port(options)}` + (path || `${pathname || ''}${search || ''}${hash || ''}`);
}

;

function getProxy(options) {
  let proxyUrl = options.protocol === 'https:' && (process.env.https_proxy || process.env.HTTPS_PROXY) || process.env.http_proxy || process.env.HTTP_PROXY;
  let shouldProxy = !!proxyUrl && !(0, _utils.hostnameMatches)(process.env.no_proxy || process.env.NO_PROXY, href(options));

  if (shouldProxy) {
    proxyUrl = new URL(proxyUrl);
    let isHttps = proxyUrl.protocol === 'https:';

    if (!isHttps && proxyUrl.protocol !== 'http:') {
      throw new Error(`Unsupported proxy protocol: ${proxyUrl.protocol}`);
    }

    let proxy = {
      isHttps
    };
    proxy.auth = !!proxyUrl.username && 'Basic ' + (proxyUrl.password ? Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`) : Buffer.from(proxyUrl.username)).toString('base64');
    proxy.host = proxyUrl.hostname;
    proxy.port = port(proxyUrl);

    proxy.connect = () => (isHttps ? _tls.default : _net.default).connect({
      rejectUnauthorized: options.rejectUnauthorized,
      host: proxy.host,
      port: proxy.port
    });

    return proxy;
  }
} // Proxified http agent


class ProxyHttpAgent extends _http.default.Agent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "httpsAgent", new _https.default.Agent({
      keepAlive: true
    }));
  }

  addRequest(request, options) {
    var _request$outputData;

    let proxy = getProxy(options);
    if (!proxy) return super.addRequest(request, options);
    (0, _logger.default)('client:proxy').debug(`Proxying request: ${options.href}`); // modify the request for proxying

    request.path = href(options);

    if (proxy.auth) {
      request.setHeader('Proxy-Authorization', proxy.auth);
    } // regenerate headers since we just changed things


    delete request._header;

    request._implicitHeader();

    if (((_request$outputData = request.outputData) === null || _request$outputData === void 0 ? void 0 : _request$outputData.length) > 0) {
      let first = request.outputData[0].data;
      let endOfHeaders = first.indexOf(CRLF.repeat(2)) + 4;
      request.outputData[0].data = request._header + first.substring(endOfHeaders);
    } // coerce the connection to the proxy


    options.port = proxy.port;
    options.host = proxy.host;
    delete options.path;

    if (proxy.isHttps) {
      // use the underlying https agent to complete the connection
      request.agent = this.httpsAgent;
      return this.httpsAgent.addRequest(request, options);
    } else {
      return super.addRequest(request, options);
    }
  }

} // Proxified https agent


exports.ProxyHttpAgent = ProxyHttpAgent;

class ProxyHttpsAgent extends _https.default.Agent {
  constructor(options) {
    // default keep-alive
    super({
      keepAlive: true,
      ...options
    });
  }

  createConnection(options, callback) {
    let proxy = getProxy(options);
    if (!proxy) return super.createConnection(options, callback);
    (0, _logger.default)('client:proxy').debug(`Proxying request: ${href(options)}`); // generate proxy connect message

    let host = `${options.hostname}:${port(options)}`;
    let connectMessage = [`CONNECT ${host} HTTP/1.1`, `Host: ${host}`];

    if (proxy.auth) {
      connectMessage.push(`Proxy-Authorization: ${proxy.auth}`);
    }

    connectMessage = connectMessage.join(CRLF);
    connectMessage += CRLF.repeat(2); // start the proxy connection and setup listeners

    let socket = proxy.connect();

    let handleError = err => {
      socket.destroy(err);
      callback(err);
    };

    let handleClose = () => handleError(new Error('Connection closed while sending request to upstream proxy'));

    let buffer = '';

    let handleData = data => {
      var _buffer$match;

      buffer += data.toString(); // haven't received end of headers yet, keep buffering

      if (!buffer.includes(CRLF.repeat(2))) return; // stop listening after end of headers

      socket.off('data', handleData);

      if (((_buffer$match = buffer.match(STATUS_REG)) === null || _buffer$match === void 0 ? void 0 : _buffer$match[1]) !== '200') {
        return handleError(new Error('Error establishing proxy connection. ' + `Response from server was: ${buffer}`));
      }

      options.socket = socket;
      options.servername = options.hostname; // callback not passed in so not to be added as a listener

      callback(null, super.createConnection(options));
    }; // send and handle the connect message


    socket.on('error', handleError).on('close', handleClose).on('data', handleData).write(connectMessage);
  }

}

exports.ProxyHttpsAgent = ProxyHttpsAgent;

function proxyAgentFor(url, options) {
  let cache = proxyAgentFor.cache || (proxyAgentFor.cache = new Map());
  let {
    protocol,
    hostname
  } = new URL(url);
  let cachekey = `${protocol}//${hostname}`;

  if (!cache.has(cachekey)) {
    cache.set(cachekey, protocol === 'https:' ? new ProxyHttpsAgent(options) : new ProxyHttpAgent(options));
  }

  return cache.get(cachekey);
} // Proxified request function that resolves with the response body when the request is successful
// and rejects when a non-successful response is received. The rejected error contains response data
// and any received error details. Server 500 errors are retried up to 5 times at 50ms intervals by
// default, and 404 errors may also be optionally retried. If a callback is provided, it is called
// with the parsed response body and response details. If the callback returns a value, that value
// will be returned in the final resolved promise instead of the response body.


function request(url, options = {}, callback) {
  // accept `request(url, callback)`
  if (typeof options === 'function') [options, callback] = [{}, options];
  let {
    body,
    retries,
    retryNotFound,
    interval,
    noProxy,
    ...requestOptions
  } = options; // allow bypassing proxied requests entirely

  if (!noProxy) requestOptions.agent || (requestOptions.agent = proxyAgentFor(url)); // parse the requested URL into request options

  let {
    protocol,
    hostname,
    port,
    pathname,
    search,
    hash
  } = new URL(url);
  return (0, _utils.retry)((resolve, reject, retry) => {
    let handleError = error => {
      if (handleError.handled) return;
      handleError.handled = true;
      let shouldRetry = error.response // maybe retry 404s and always retry 500s
      ? retryNotFound && error.response.status === 404 || error.response.status >= 500 && error.response.status < 600 // retry specific error codes
      : !!error.code && RETRY_ERROR_CODES.includes(error.code);
      return shouldRetry ? retry(error) : reject(error);
    };

    let handleFinished = async (body, res) => {
      let raw = body; // attempt to parse the body as json

      try {
        body = JSON.parse(body);
      } catch (e) {}

      try {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          var _await$callback, _callback;

          // resolve successful statuses after the callback
          resolve((_await$callback = await ((_callback = callback) === null || _callback === void 0 ? void 0 : _callback(body, res))) !== null && _await$callback !== void 0 ? _await$callback : body);
        } else {
          var _body, _body$errors, _body$errors$find;

          // use the first error detail or the status message
          throw new Error(((_body = body) === null || _body === void 0 ? void 0 : (_body$errors = _body.errors) === null || _body$errors === void 0 ? void 0 : (_body$errors$find = _body$errors.find(e => e.detail)) === null || _body$errors$find === void 0 ? void 0 : _body$errors$find.detail) || `${res.statusCode} ${res.statusMessage || raw}`);
        }
      } catch (error) {
        handleError(Object.assign(error, {
          response: {
            status: res.statusCode,
            body
          }
        }));
      }
    };

    let handleResponse = res => {
      let body = '';
      res.setEncoding('utf8');
      res.on('data', chunk => body += chunk);
      res.on('end', () => handleFinished(body, res));
      res.on('error', handleError);
    };

    let req = (protocol === 'https:' ? _https.default : _http.default).request({ ...requestOptions,
      path: pathname + search + hash,
      protocol,
      hostname,
      port
    });
    req.on('response', handleResponse);
    req.on('error', handleError);
    req.end(body);
  }, {
    retries,
    interval
  });
}

var _default = request;
exports.default = _default;