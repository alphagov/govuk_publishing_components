"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.create = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _cliCommand = _interopRequireDefault(require("@percy/cli-command"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const DEFAULT_FILES = {
  rc: '.percyrc',
  yaml: '.percy.yaml',
  yml: '.percy.yml',
  json: '.percy.json',
  js: '.percy.js'
};
const FILETYPES = Object.keys(DEFAULT_FILES);
const create = (0, _cliCommand.default)('create', {
  description: 'Create a Percy config file',
  args: [{
    name: 'filepath',
    description: 'Optional config filepath'
  }],
  flags: [{
    name: 'rc',
    description: 'Create a .percyrc file',
    conflicts: FILETYPES.filter(t => t !== 'rc'),
    type: 'boolean'
  }, {
    name: 'yaml',
    description: 'Create a .percy.yaml file',
    conflicts: FILETYPES.filter(t => t !== 'yaml'),
    type: 'boolean'
  }, {
    name: 'yml',
    description: 'Create a .percy.yml file',
    conflicts: FILETYPES.filter(t => t !== 'yml'),
    type: 'boolean'
  }, {
    name: 'json',
    description: 'Create a .percy.json file',
    conflicts: FILETYPES.filter(t => t !== 'json'),
    type: 'boolean'
  }, {
    name: 'js',
    description: 'Create a .percy.js file',
    conflicts: FILETYPES.filter(t => t !== 'js'),
    type: 'boolean'
  }],
  examples: ['$0', '$0 --yaml', '$0 --json', '$0 --js', '$0 --rc', '$0 ./config/percy.yml']
}, async ({
  flags,
  args,
  log,
  exit
}) => {
  var _FILETYPES$find;

  let PercyConfig = await Promise.resolve().then(() => _interopRequireWildcard(require('@percy/config'))); // discern the filetype

  let filetype = args.filepath ? _path.default.extname(args.filepath).replace(/^./, '') : (_FILETYPES$find = FILETYPES.find(t => flags[t])) !== null && _FILETYPES$find !== void 0 ? _FILETYPES$find : 'yml'; // verify the filetype is supported

  if (!DEFAULT_FILES[filetype]) {
    exit(1, `Unsupported filetype: ${filetype}`);
  } // default filepath based on filetype


  let filepath = args.filepath || DEFAULT_FILES[filetype]; // verify the file does not already exist

  if (_fs.default.existsSync(filepath)) {
    exit(1, `Percy config already exists: ${filepath}`);
  } // write stringified default config options to the filepath


  let format = ['rc', 'yaml', 'yml'].includes(filetype) ? 'yaml' : filetype;

  _fs.default.writeFileSync(filepath, PercyConfig.stringify(format));

  log.info(`Created Percy config: ${filepath}`);
});
exports.create = create;
var _default = create;
exports.default = _default;