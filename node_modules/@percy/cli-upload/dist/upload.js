"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.upload = exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _cliCommand = _interopRequireDefault(require("@percy/cli-command"));

var UploadConfig = _interopRequireWildcard(require("./config"));

var _package = _interopRequireDefault(require("../package.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const ALLOWED_FILE_TYPES = /\.(png|jpg|jpeg)$/i;
const upload = (0, _cliCommand.default)('upload', {
  description: 'Upload a directory of images to Percy',
  args: [{
    name: 'dirname',
    description: 'Directory of images to upload',
    required: true,
    validate: dir => {
      if (!_fs.default.existsSync(dir)) {
        throw new Error(`Not found: ${dir}`);
      } else if (!_fs.default.lstatSync(dir).isDirectory()) {
        throw new Error(`Not a directory: ${dir}`);
      }
    }
  }],
  flags: [{
    name: 'files',
    description: 'One or more globs matching image file paths to upload',
    default: UploadConfig.schema.upload.properties.files.default,
    percyrc: 'upload.files',
    type: 'pattern',
    multiple: true,
    short: 'f'
  }, {
    name: 'ignore',
    description: 'One or more globs matching image file paths to ignore',
    percyrc: 'upload.ignore',
    type: 'pattern',
    multiple: true,
    short: 'i'
  }, {
    name: 'strip-extensions',
    description: 'Strips file extensions from snapshot names',
    percyrc: 'upload.stripExtensions',
    short: 'e'
  }],
  examples: ['$0 ./images'],
  percy: {
    clientInfo: `${_package.default.name}/${_package.default.version}`,
    environmentInfo: `node/${process.version}`,
    discoveryFlags: false,
    deferUploads: true
  },
  config: {
    schemas: [UploadConfig.schema],
    migrations: [UploadConfig.migration]
  }
}, async function* ({
  flags,
  args,
  percy,
  log,
  exit
}) {
  if (!percy) exit(0, 'Percy is disabled');
  let config = percy.config.upload;
  let {
    default: globby
  } = await Promise.resolve().then(() => _interopRequireWildcard(require('globby')));
  let pathnames = yield globby(config.files, {
    ignore: [].concat(config.ignore || []),
    cwd: args.dirname
  });

  if (!pathnames.length) {
    exit(1, `No matching files found in '${args.dirname}'`);
  }

  let {
    default: imageSize
  } = await Promise.resolve().then(() => _interopRequireWildcard(require('image-size')));
  let {
    createImageResources
  } = await Promise.resolve().then(() => _interopRequireWildcard(require('./resources'))); // the internal upload queue shares a concurrency with the snapshot queue

  percy.setConfig({
    discovery: {
      concurrency: config.concurrency
    }
  }); // do not launch a browser when starting

  yield percy.start({
    browser: false
  });

  for (let filename of pathnames) {
    let file = _path.default.parse(filename);

    let name = config.stripExtensions ? _path.default.join(file.dir, file.name) : filename;

    if (!ALLOWED_FILE_TYPES.test(filename)) {
      log.info(`Skipping unsupported file type: ${filename}`);
    } else {
      if (percy.dryRun) log.info(`Snapshot found: ${name}`);

      percy._scheduleUpload(filename, async () => {
        let filepath = _path.default.resolve(args.dirname, filename);

        let buffer = _fs.default.readFileSync(filepath); // width and height is clamped to API min and max


        let size = imageSize(filepath);
        let widths = [Math.max(10, Math.min(size.width, 2000))];
        let minHeight = Math.max(10, Math.min(size.height, 2000));
        let resources = createImageResources(filename, buffer, size);
        return {
          name,
          widths,
          minHeight,
          resources
        };
      }).then(() => {
        log.info(`Snapshot uploaded: ${name}`);
      });
    }
  }

  try {
    yield* percy.stop();
  } catch (error) {
    await percy.stop(true);
    throw error;
  }
});
exports.upload = upload;
var _default = upload;
exports.default = _default;