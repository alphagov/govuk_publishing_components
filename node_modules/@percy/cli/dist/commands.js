"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.importCommands = importCommands;

var _os = _interopRequireDefault(require("os"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _module = require("module");

var _logger = _interopRequireDefault(require("@percy/logger"));

var _cliCommand = require("@percy/cli-command");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Helper to simplify reducing async functions
async function reduceAsync(iter, reducer, accum = []) {
  for (let i of iter) accum = await reducer(accum, i);

  return accum;
} // Helper to read and reduce files within a directory


function reduceFiles(dir, reducer) {
  return reduceAsync(_fs.default.readdirSync(dir, {
    withFileTypes: true
  }), reducer);
} // Returns the paths of potential percy packages found within node_modules


function findModulePackages(dir) {
  try {
    // not given node_modules or a directory that contains node_modules, look up
    if (_path.default.basename(dir) !== 'node_modules') {
      let modulesPath = _path.default.join(dir, 'node_modules');

      let next = _fs.default.existsSync(modulesPath) ? modulesPath : _path.default.dirname(dir);
      if (next === dir || next === _os.default.homedir()) return [];
      return findModulePackages(next);
    } // given node modules, look for percy packages


    return reduceFiles(dir, async (roots, file) => {
      let rootPath = _path.default.join(dir, file.name);

      if (file.name === '@percy') {
        return roots.concat(await reduceFiles(rootPath, (dirs, f) => // specifically protect against files to allow linked directories
        f.isFile() ? dirs : dirs.concat(_path.default.join(rootPath, f.name)), []));
      } else if (file.name.startsWith('percy-cli-')) {
        return roots.concat(rootPath);
      } else {
        return roots;
      }
    }, []);
  } catch (error) {
    (0, _logger.default)('cli:plugins').debug(error);
    return [];
  }
} // Used by `findPnpPackages` to filter Percy CLI plugins


const PERCY_PKG_REG = /^(@percy\/|percy-cli-)/; // Returns the paths of potential percy packages found within yarn's pnp system

function findPnpPackages(dir) {
  var _pkgInfo$packageDepen;

  let pnpapi = _module.findPnpApi === null || _module.findPnpApi === void 0 ? void 0 : (0, _module.findPnpApi)(`${dir}/`);
  let pkgLoc = pnpapi === null || pnpapi === void 0 ? void 0 : pnpapi.findPackageLocator(`${dir}/`);
  let pkgInfo = pkgLoc && (pnpapi === null || pnpapi === void 0 ? void 0 : pnpapi.getPackageInformation(pkgLoc));
  let pkgDeps = (_pkgInfo$packageDepen = pkgInfo === null || pkgInfo === void 0 ? void 0 : pkgInfo.packageDependencies.entries()) !== null && _pkgInfo$packageDepen !== void 0 ? _pkgInfo$packageDepen : [];
  return Array.from(pkgDeps).reduce((roots, [name, ref]) => {
    if (!ref || !PERCY_PKG_REG.test(name)) return roots;
    let depLoc = pnpapi.getLocator(name, ref);
    let depInfo = pnpapi.getPackageInformation(depLoc);
    return roots.concat(depInfo.packageLocation);
  }, []);
} // Helper to import and wrap legacy percy commands for reverse compatibility


function importLegacyCommands(commandsPath) {
  return reduceFiles(commandsPath, async (cmds, file) => {
    let {
      name
    } = _path.default.parse(file.name);

    let filepath = _path.default.join(commandsPath, name);

    if (file.isDirectory()) {
      // recursively import nested commands and find the index command
      let commands = await importLegacyCommands(filepath);
      let index = commands.findIndex(cmd => cmd.name === 'index'); // modify or create an index command to hold nested commands

      index = ~index ? commands.splice(index, 1)[0] : (0, _cliCommand.command)();
      Object.defineProperty(index, 'name', {
        value: name
      });
      index.definition.commands = commands;
      return cmds.concat(index);
    } else {
      // find and wrap the command exported by the module
      let exports = Object.values(await Promise.resolve(`${filepath}`).then(s => _interopRequireWildcard(require(s))));
      let cmd = exports.find(e => {
        var _e$prototype;

        return typeof (e === null || e === void 0 ? void 0 : (_e$prototype = e.prototype) === null || _e$prototype === void 0 ? void 0 : _e$prototype.run) === 'function';
      });
      return cmd ? cmds.concat((0, _cliCommand.legacyCommand)(name, cmd)) : cmds;
    }
  });
} // Imports and returns compatibile CLI commands from various sources


async function importCommands() {
  // start with a set to get built-in deduplication
  let cmdPkgs = await reduceAsync(new Set([// find included dependencies
  _path.default.join(__dirname, '..'), // find potential sibling packages
  _path.default.join(__dirname, '..', '..'), // find any current project dependencies
  process.cwd()]), async (roots, dir) => {
    roots.push(...(await findModulePackages(dir)));
    roots.push(...(await findPnpPackages(dir)));
    return roots;
  }); // reduce found packages to functions which import cli commands

  let cmdImports = await reduceAsync(cmdPkgs, async (pkgs, pkgPath) => {
    var _pkg$oclif, _pkg$PercyCli;

    let pkg = require(_path.default.join(pkgPath, 'package.json')); // do not include self


    if (pkg.name === '@percy/cli') return pkgs; // support legacy oclif percy commands

    if (((_pkg$oclif = pkg.oclif) === null || _pkg$oclif === void 0 ? void 0 : _pkg$oclif.bin) === 'percy') {
      pkgs.set(pkg.name, async () => {
        var _pkg$oclif$hooks;

        if ((_pkg$oclif$hooks = pkg.oclif.hooks) !== null && _pkg$oclif$hooks !== void 0 && _pkg$oclif$hooks.init) {
          let initPath = _path.default.join(pkgPath, pkg.oclif.hooks.init);

          let init = await Promise.resolve(`${initPath}`).then(s => _interopRequireWildcard(require(s)));
          await init.default();
        }

        if (pkg.oclif.commands) {
          let commandsPath = _path.default.join(pkgPath, pkg.oclif.commands);

          return importLegacyCommands(commandsPath);
        }

        return [];
      });
    } // overwrite any found package of the same name


    if ((_pkg$PercyCli = pkg['@percy/cli']) !== null && _pkg$PercyCli !== void 0 && _pkg$PercyCli.commands) {
      pkgs.set(pkg.name, () => Promise.all(pkg['@percy/cli'].commands.map(async cmdPath => {
        let module = await Promise.resolve(`${_path.default.join(pkgPath, cmdPath)}`).then(s => _interopRequireWildcard(require(s)));
        return module.default;
      })));
    }

    return pkgs;
  }, new Map()); // actually import found commands

  let cmds = await reduceAsync(cmdImports.values(), async (cmds, importCmds) => cmds.concat(await importCmds())); // sort standalone commands before command topics

  return cmds.sort((a, b) => {
    if (a.callback && !b.callback) return -1;
    if (b.callback && !a.callback) return 1;
    return a.name.localeCompare(b.name);
  });
}