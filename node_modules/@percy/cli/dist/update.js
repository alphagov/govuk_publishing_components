"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkForUpdate = checkForUpdate;
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("@percy/logger"));

var _util = require("@percy/logger/dist/util");

var _package = _interopRequireDefault(require("../package.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// filepath where the cache will be read and written to
const CACHE_FILE = _path.default.join(__dirname, '..', '.releases'); // max age the cache should be used for (3 days)


const CACHE_MAX_AGE = 3 * 24 * 60 * 60 * 1000; // Safely read from CACHE_FILE and return an object containing `data` mirroring what was previously
// written using `writeToCache(data)`. An empty object is returned when older than CACHE_MAX_AGE,
// and an `error` will be present if one was encountered.

function readFromCache() {
  let cached = {};

  try {
    if (_fs.default.existsSync(CACHE_FILE)) {
      let {
        createdAt,
        data
      } = JSON.parse(_fs.default.readFileSync(CACHE_FILE));
      if (Date.now() - createdAt < CACHE_MAX_AGE) cached.data = data;
    }
  } catch (error) {
    let log = (0, _logger.default)('cli:update:cache');
    log.debug('Unable to read from cache');
    log.debug(cached.error = error);
  }

  return cached;
} // Safely write data to CACHE_FILE with the current timestamp.


function writeToCache(data) {
  try {
    _fs.default.writeFileSync(CACHE_FILE, JSON.stringify({
      createdAt: Date.now(),
      data
    }));
  } catch (error) {
    let log = (0, _logger.default)('cli:update:cache');
    log.debug('Unable to write to cache');
    log.debug(error);
  }
} // Fetch and return release information for @percy/cli.


async function fetchReleases() {
  let {
    request
  } = await Promise.resolve().then(() => _interopRequireWildcard(require('@percy/client/dist/request'))); // fetch releases from the github api without retries

  let api = 'https://api.github.com/repos/percy/cli/releases';
  let data = await request(api, {
    headers: {
      'User-Agent': _package.default.name
    },
    retries: 0
  }); // return relevant information

  return data.map(r => ({
    tag: r.tag_name,
    prerelease: r.prerelease
  }));
} // Check for updates by comparing latest releases with the current version. The result of the check
// is cached to speed up subsequent CLI usage.


async function checkForUpdate() {
  let {
    data: releases,
    error: cacheError
  } = readFromCache();
  let log = (0, _logger.default)('cli:update');

  try {
    // request new release information if needed
    if (!releases) {
      releases = await fetchReleases();
      if (!cacheError) writeToCache(releases, log);
    } // check the current package version against released versions


    let versions = releases.map(r => r.tag.substr(1));
    let age = versions.indexOf(_package.default.version); // a new version is available

    if (age !== 0) {
      let range = `${_util.colors.red(_package.default.version)} -> ${_util.colors.green(versions[0])}`;
      log.stderr.write('\n');
      log.warn(`${age > 0 && age < 10 ? 'A new version of @percy/cli is available!' : 'Heads up! The current version of @percy/cli is more than 10 releases behind!'} ${range}`);
      log.stderr.write('\n');
    }
  } catch (err) {
    log.debug('Unable to check for updates');
    log.debug(err);
  }
}

var _default = checkForUpdate;
exports.default = _default;