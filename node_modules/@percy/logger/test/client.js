(function() {
  this.PercyLogger = this.PercyLogger || {};
  this.PercyLogger.TestHelpers = (function (require$$0, require$$2) {
  	'use strict';

  	const process = (typeof globalThis !== "undefined" && globalThis.process) || {};
  	process.env = process.env || {};
  	process.env.__PERCY_BROWSERIFIED__ = true;

  	globalThis.process = globalThis.process || process;

  	function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  	var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
  	var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);

  	function getAugmentedNamespace(n) {
  		if (n.__esModule) return n;
  		var a = Object.defineProperty({}, '__esModule', {value: true});
  		Object.keys(n).forEach(function (k) {
  			var d = Object.getOwnPropertyDescriptor(n, k);
  			Object.defineProperty(a, k, d.get ? d : {
  				enumerable: true,
  				get: function () {
  					return n[k];
  				}
  			});
  		});
  		return a;
  	}

  	const {
  	  assign,
  	  entries
  	} = Object; // matches ansi escape sequences

  	const ANSI_REG$1 = new RegExp('[\\u001B\\u009B][[\\]()#;?]*((?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)' + '|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))', 'g'); // color names by ansi escape code

  	const ANSI_COLORS = {
  	  '91m': 'red',
  	  '32m': 'green',
  	  '93m': 'yellow',
  	  '34m': 'blue',
  	  '95m': 'magenta',
  	  '90m': 'grey'
  	}; // colorize each line of a string using an ansi escape sequence

  	const LINE_REG = /^.*$/gm;

  	function colorize(code, str) {
  	  return str.replace(LINE_REG, line => `\u001b[${code}${line}\u001b[39m`);
  	} // map ansi colors to bound colorize functions


  	const colors = entries(ANSI_COLORS).reduce((colors, _ref) => {
  	  let [code, name] = _ref;
  	  return assign(colors, {
  	    [name]: colorize.bind(null, code)
  	  });
  	}, {});

  	var util = /*#__PURE__*/Object.freeze({
  		__proto__: null,
  		ANSI_REG: ANSI_REG$1,
  		ANSI_COLORS: ANSI_COLORS,
  		colors: colors
  	});

  	var require$$1 = /*@__PURE__*/getAugmentedNamespace(util);

  	const logger = require$$0__default["default"];
  	const {
  	  ANSI_REG
  	} = require$$1;
  	const {
  	  Logger
  	} = logger;
  	const ELAPSED_REG = /\s\S*?\(\d+ms\)\S*/;
  	const NEWLINE_REG = /\r\n/g;
  	const LASTLINE_REG = /\n$/;

  	function sanitizeLog(str) {
  	  let {
  	    ansi,
  	    elapsed
  	  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	  // normalize line endings
  	  str = str.replace(NEWLINE_REG, '\n'); // strip ansi colors

  	  if (!ansi) str = str.replace(ANSI_REG, ''); // strip elapsed time

  	  if (!elapsed) str = str.replace(ELAPSED_REG, ''); // strip trailing line endings

  	  return str.replace(LASTLINE_REG, '');
  	}

  	function TestIO(data, options) {
  	  if (!process.env.__PERCY_BROWSERIFIED__) {
  	    let {
  	      Writable
  	    } = require$$2__default["default"];
  	    return Object.assign(new Writable(), {
  	      isTTY: options && options.isTTY,

  	      cursorTo() {},

  	      clearLine() {},

  	      _write(chunk, encoding, callback) {
  	        data.push(sanitizeLog(chunk.toString(), options));
  	        callback();
  	      }

  	    });
  	  }
  	}

  	function spy(object, method, func) {
  	  if (object[method].reset) {
  	    object[method].reset();
  	    return object[method];
  	  }

  	  let spy = Object.assign(function spy() {
  	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
  	      args[_key] = arguments[_key];
  	    }

  	    spy.calls.push(args);
  	    if (func) return func.apply(this, args);
  	  }, {
  	    restore: () => object[method] = spy.originalValue,
  	    reset: () => spy.calls.length = 0,
  	    originalValue: object[method],
  	    calls: []
  	  });
  	  object[method] = spy;
  	  return spy;
  	}

  	const helpers = {
  	  constructor: Logger,
  	  loglevel: logger.loglevel,
  	  stdout: [],
  	  stderr: [],

  	  get messages() {
  	    return Logger.instance && Logger.instance.messages;
  	  },

  	  mock(options) {
  	    helpers.reset();
  	    helpers.options = options;

  	    if (!process.env.__PERCY_BROWSERIFIED__) {
  	      Logger.stdout = TestIO(helpers.stdout, options);
  	      Logger.stderr = TestIO(helpers.stderr, options);
  	    } else {
  	      spy(Logger.prototype, 'write', function (lvl, msg) {
  	        let stdio = lvl === 'info' ? 'stdout' : 'stderr';
  	        helpers[stdio].push(sanitizeLog(msg, helpers.options));
  	        return this.write.originalValue.call(this, lvl, msg);
  	      });
  	      spy(console, 'log');
  	      spy(console, 'warn');
  	      spy(console, 'error');
  	    }
  	  },

  	  reset(soft) {
  	    if (soft) Logger.instance.loglevel('info');else delete Logger.instance;
  	    helpers.stdout.length = 0;
  	    helpers.stderr.length = 0;

  	    if (console.log.reset) {
  	      console.log.reset();
  	      console.warn.reset();
  	      console.error.reset();
  	    }
  	  },

  	  dump() {
  	    if (!helpers.messages || !helpers.messages.size) return;
  	    if (console.log.and) console.log.and.callThrough();

  	    let write = m => process.env.__PERCY_BROWSERIFIED__ ? console.log(m) : process.stderr.write(`${m}\n`);

  	    let logs = Array.from(helpers.messages);
  	    logger.loglevel('debug');
  	    write(logger.format('testing', 'warn', '--- DUMPING LOGS ---'));
  	    logs.reduce((lastlog, _ref) => {
  	      let {
  	        debug,
  	        level,
  	        message,
  	        timestamp
  	      } = _ref;
  	      write(logger.format(debug, level, message, timestamp - lastlog));
  	      return timestamp;
  	    }, logs[0].timestamp);
  	  }

  	};
  	var helpers_1 = helpers;

  	return helpers_1;

  })(PercyLogger, null);
}).call(window);

if (typeof define === "function" && define.amd) {
  define([], () => window.PercyLogger.TestHelpers);
} else if (typeof module === "object" && module.exports) {
  module.exports = window.PercyLogger.TestHelpers;
}
