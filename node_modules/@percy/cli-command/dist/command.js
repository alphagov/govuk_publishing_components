"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.command = command;
exports.default = void 0;

var _logger = _interopRequireDefault(require("@percy/logger"));

var _config = _interopRequireDefault(require("@percy/config"));

var _utils = require("@percy/config/dist/utils");

var CoreConfig = _interopRequireWildcard(require("@percy/core/dist/config"));

var builtInFlags = _interopRequireWildcard(require("./flags"));

var _help = _interopRequireDefault(require("./help"));

var _parse = _interopRequireDefault(require("./parse"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Copies a command definition and adds built-in flags and config options.
function withBuiltIns(definition) {
  var _def$flags, _def$config$schemas, _def$config$migration;

  let def = { ...definition
  };
  def.flags = [...((_def$flags = def.flags) !== null && _def$flags !== void 0 ? _def$flags : [])]; // ensure built-ins aren't already overridden

  let addDedupedFlag = flag => {
    if (!def.flags.find(f => f.name === flag.name)) {
      let short = def.flags.find(f => f.short === flag.short);
      def.flags.push(short ? (0, _utils.del)({ ...flag
      }, 'short') : flag);
    }
  }; // add percy specific built-in flags


  if (def.percy && def.percy !== true) {
    builtInFlags.PERCY.forEach(addDedupedFlag); // maybe include percy discovery flags

    if (def.percy.discoveryFlags !== false) {
      builtInFlags.DISCOVERY.forEach(addDedupedFlag);
    }
  } // always add global built-in flags


  builtInFlags.GLOBAL.forEach(addDedupedFlag); // copy any existing config before adding to it

  def.config = { ...def.config
  };
  def.config.schemas = [...((_def$config$schemas = def.config.schemas) !== null && _def$config$schemas !== void 0 ? _def$config$schemas : [])];
  def.config.migrations = [...((_def$config$migration = def.config.migrations) !== null && _def$config$migration !== void 0 ? _def$config$migration : [])]; // add percy specific built-in config options

  if (def.percy) {
    def.config.schemas.unshift(...CoreConfig.schemas);
    def.config.migrations.unshift(...CoreConfig.migrations);
  }

  return def;
} // Calls the provided callback and handles callback cancelation when process signals are
// triggered. If the provided callback returns a generator, it will automatically run and throw
// an error when canceled to be able to gracefully handle it's own cancelation.


async function handleProcessSignals(callback) {
  let signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
  let signalError; // keep track of signal handlers for cleanup

  let signalHandlers = signals.map(signal => {
    let handler = () => {
      signalError = Object.assign(new Error(signal), {
        canceled: true,
        exitCode: 0,
        signal
      });
    };

    process.on(signal, handler);
    return [signal, handler];
  });

  try {
    // maybe async function
    let gen = await callback(); // run any returned generator

    if (typeof (gen === null || gen === void 0 ? void 0 : gen.next) === 'function' && (typeof gen[Symbol.iterator] === 'function' || typeof gen[Symbol.asyncIterator] === 'function')) {
      let result = await gen.next();

      while (!result.done) {
        result = signalError ? await gen.throw(signalError) : await gen.next(result.value);
      }
    }
  } finally {
    // always cleanup
    for (let [signal, handler] of signalHandlers) {
      process.off(signal, handler);
    }
  }
} // Helper to throw an error with an exit code and optional reason message


function exit(exitCode, reason = '') {
  let err = reason instanceof Error ? reason : new Error(reason);
  throw Object.assign(err, {
    exitCode
  });
} // Runs the parsed command callback with a contextual argument consisting of specific parsed input
// and other common command helpers and properties.


async function runCommandWithContext(parsed) {
  let {
    command,
    flags,
    args,
    argv,
    log
  } = parsed; // include flags, args, argv, logger, exit helper, and env info

  let context = {
    flags,
    args,
    argv,
    log,
    exit
  };
  let env = context.env = process.env;
  let def = command.definition; // automatically include a preconfigured percy instance

  if (def.percy) {
    let {
      Percy
    } = await Promise.resolve().then(() => _interopRequireWildcard(require('@percy/core'))); // set defaults and prune preconfiguraton options

    let conf = (0, _utils.del)({
      server: false,
      ...def.percy
    }, 'discoveryFlags');
    Object.defineProperty(context, 'percy', {
      configurable: true,

      get() {
        // percy is disabled, do not return an instance
        if (env.PERCY_ENABLE === '0') return; // redefine the context property once configured

        Object.defineProperty(context, 'percy', {
          // map and merge percy arguments with config options
          value: new Percy([...parsed.operators.entries()].reduce((conf, [opt, value]) => opt.percyrc ? (0, _utils.set)(conf, opt.percyrc, value) : conf, conf))
        });
        return context.percy;
      }

    });
  } // wrap and bind the parsed command callback


  await handleProcessSignals(command.callback.bind(null, context));
} // Returns a command runner function that when run will parse provided command-line options and run
// the parsed command callback. The returned runner will automatically output version and help
// information when requested, and handle any thrown errors exiting when appropriate.


function command(name, definition, callback) {
  definition = withBuiltIns(definition); // auto register config schemas and migrations

  _config.default.addSchema(definition.config.schemas);

  _config.default.addMigration(definition.config.migrations);

  async function runner(argv = []) {
    // reset loglevel for testing
    _logger.default.loglevel('info');

    let log = (0, _logger.default)('cli');

    try {
      // parse input
      let parsed = await (0, _parse.default)(runner, argv);

      if (parsed.version) {
        // version requested
        log.stdout.write(parsed.command.definition.version + '\n');
      } else if (parsed.help || !parsed.command.callback) {
        // command help requested
        log.stdout.write((await (0, _help.default)(parsed.command)) + '\n');
      } else {
        // run command callback
        await runCommandWithContext(parsed);
      }
    } catch (err) {
      // auto log unhandled error messages
      if (err.message && !err.signal) {
        if (err.exitCode === 0) log.warn(err.message);else log.error(err);
      } // exit when appropriate


      if (err.exitCode !== 0) {
        var _err$exitCode;

        (_err$exitCode = err.exitCode) !== null && _err$exitCode !== void 0 ? _err$exitCode : err.exitCode = 1;
        err.message || (err.message = `EEXIT: ${err.exitCode}`);

        if (definition.exitOnError) {
          process.exit(err.exitCode);
        } // re-throw when not exiting


        throw err;
      }
    }
  } // define command meta information


  Object.defineProperties(runner, {
    name: {
      enumerable: true,
      value: name
    },
    definition: {
      enumerable: true,
      value: definition
    },
    callback: {
      enumerable: true,
      value: callback
    }
  });
  return runner;
}

var _default = command;
exports.default = _default;