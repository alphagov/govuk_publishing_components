"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.snapshot = exports.default = void 0;

var _fs = require("fs");

var _cliCommand = _interopRequireDefault(require("@percy/cli-command"));

var SnapshotConfig = _interopRequireWildcard(require("./config"));

var _package = _interopRequireDefault(require("../package.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const snapshot = (0, _cliCommand.default)('snapshot', {
  description: 'Snapshot a static directory, snapshots file, or sitemap URL',
  args: [{
    name: 'dir|file|sitemap',
    description: 'Static directory, snapshots file, or sitemap url',
    required: true,
    attribute: val => {
      if (/^https?:\/\//.test(val)) return 'sitemap';
      if (!(0, _fs.existsSync)(val)) throw new Error(`Not found: ${val}`);
      return (0, _fs.lstatSync)(val).isDirectory() ? 'dir' : 'file';
    }
  }],
  flags: [{
    name: 'base-url',
    description: 'The base url pages are hosted at when snapshotting',
    type: 'string',
    short: 'b'
  }, {
    name: 'include',
    description: 'One or more globs/patterns matching snapshots to include',
    type: 'pattern',
    multiple: true
  }, {
    name: 'exclude',
    description: 'One or more globs/patterns matching snapshots to exclude',
    type: 'pattern',
    multiple: true
  }, {
    // static only
    name: 'clean-urls',
    description: 'Rewrite static index and filepath URLs to be clean',
    percyrc: 'static.cleanUrls',
    group: 'Static'
  }, {
    // deprecated
    name: 'files',
    deprecated: ['1.0.0', '--include'],
    percyrc: 'static.include',
    type: 'pattern'
  }, {
    name: 'ignore',
    deprecated: ['1.0.0', '--exclude'],
    percyrc: 'static.exclude',
    type: 'pattern'
  }],
  examples: ['$0 ./public', '$0 snapshots.yml', '$0 https://percy.io/sitemap.xml'],
  percy: {
    clientInfo: `${_package.default.name}/${_package.default.version}`,
    environmentInfo: `node/${process.version}`
  },
  config: {
    schemas: [SnapshotConfig.commonSchema, SnapshotConfig.configSchema, SnapshotConfig.snapshotsFileSchema],
    migrations: [SnapshotConfig.configMigration]
  }
}, async function* ({
  percy,
  args,
  flags,
  log,
  exit
}) {
  if (!percy) exit(0, 'Percy is disabled'); // set and validate static or sitemap config flags

  if (args.dir || args.sitemap) {
    percy.setConfig({
      [args.dir ? 'static' : 'sitemap']: {
        include: flags.include,
        exclude: flags.exclude
      }
    });
  } // gather snapshots


  let snapshots, server;

  try {
    if (args.sitemap) {
      let {
        loadSitemapSnapshots
      } = await Promise.resolve().then(() => _interopRequireWildcard(require('./sitemap')));
      let config = { ...percy.config.sitemap,
        ...flags
      };
      snapshots = yield loadSitemapSnapshots(args.sitemap, config);
    } else if (args.dir) {
      let {
        serve,
        loadStaticSnapshots
      } = await Promise.resolve().then(() => _interopRequireWildcard(require('./static')));
      let config = { ...percy.config.static,
        ...flags
      };
      server = yield serve(args.dir, config);
      snapshots = yield loadStaticSnapshots(args.dir, { ...config,
        server
      });
    } else {
      let {
        loadSnapshotsFile
      } = await Promise.resolve().then(() => _interopRequireWildcard(require('./file')));
      snapshots = yield loadSnapshotsFile(args.file, flags, (invalid, i) => {
        if (i === 0) log.warn('Invalid snapshot options:');
        log.warn(`- ${invalid.path}: ${invalid.message}`);
      });
    }

    if (!snapshots.length) {
      exit(1, 'No snapshots found');
    } // start processing snapshots


    yield* percy.start();
    percy.snapshot(snapshots);
    yield* percy.stop();
  } catch (error) {
    await percy.stop(true);
    throw error;
  } finally {
    var _server;

    await ((_server = server) === null || _server === void 0 ? void 0 : _server.close());
  }
});
exports.snapshot = snapshot;
var _default = snapshot;
exports.default = _default;