"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadStaticSnapshots = loadStaticSnapshots;
exports.mapStaticSnapshots = mapStaticSnapshots;
exports.serve = serve;

var _path = _interopRequireDefault(require("path"));

var _http = require("http");

var _serveHandler = _interopRequireDefault(require("serve-handler"));

var pathToRegexp = _interopRequireWildcard(require("path-to-regexp"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Transforms a source-destination map into an array of source-destination objects
function mapRewrites(map, arr) {
  return Object.entries(map).reduce((r, [source, destination]) => {
    return (r || []).concat({
      source,
      destination
    });
  }, arr);
} // Serves a static directory with the provided options and returns an object containing adjusted
// rewrites (combined with any baseUrl), the server host, a close method, and the server
// instance. The `dryRun` option will prevent the server from actually starting.


async function serve(dir, {
  dryRun,
  baseUrl,
  cleanUrls,
  rewrites = {}
}) {
  let host = 'http://localhost';
  let connections = new Set(); // coerce any provided base-url into a base-url path

  if (baseUrl && !baseUrl.startsWith('/')) {
    baseUrl = (0, _utils.validURL)(baseUrl).path;
  } // map rewrite options with the base-url


  rewrites = mapRewrites(rewrites, baseUrl && [{
    source: _path.default.posix.join(baseUrl, '/:path*'),
    destination: '/:path*'
  }]); // start the server

  let server = !dryRun && (await new Promise(resolve => {
    let server = (0, _http.createServer)((req, res) => (0, _serveHandler.default)(req, res, {
      public: dir,
      cleanUrls,
      rewrites
    })).listen(() => resolve(server)).on('connection', s => {
      connections.add(s.on('close', () => connections.delete(s)));
    });
  })); // easy clean up

  let close = () => server && new Promise(resolve => {
    /* istanbul ignore next: sometimes needed when connections are hanging */
    connections.forEach(s => s.destroy());
    server.close(resolve);
  }); // add the port to the host and return


  if (server) host += `:${server.address().port}`;
  return {
    host,
    rewrites,
    server,
    close
  };
} // Maps an array of snapshots or paths to options ready to pass along to the core snapshot
// method. Paths are normalized before overrides are conditionally applied via their own include and
// exclude options. Snapshot URLs are then rewritten accordingly before default options are applied,
// including prepending the appropriate host. The returned set of snapshot options are sorted and
// filtered by the top-level include and exclude options.


function mapStaticSnapshots(snapshots,
/* istanbul ignore next: safe defaults */
{
  host,
  include,
  exclude,
  cleanUrls,
  rewrites = [],
  overrides = [],
  server
} = {}) {
  var _server$host, _server$rewrites;

  // prioritize server properties
  host = (_server$host = server === null || server === void 0 ? void 0 : server.host) !== null && _server$host !== void 0 ? _server$host : host;
  rewrites = (_server$rewrites = server === null || server === void 0 ? void 0 : server.rewrites) !== null && _server$rewrites !== void 0 ? _server$rewrites : mapRewrites(rewrites, []); // reduce rewrites into a single function

  let applyRewrites = [{
    test: url => !/^(https?:\/)?\//.test(url) && url,
    rewrite: url => _path.default.posix.normalize(_path.default.posix.join('/', url))
  }, ...rewrites.map(({
    source,
    destination
  }) => ({
    test: pathToRegexp.match(destination),
    rewrite: pathToRegexp.compile(source)
  })), {
    test: url => cleanUrls && url,
    rewrite: url => url.replace(/(\/index)?\.html$/, '')
  }].reduceRight((apply, {
    test,
    rewrite
  }) => snap => {
    var _snap$url, _res$params;

    let res = test((_snap$url = snap.url) !== null && _snap$url !== void 0 ? _snap$url : snap);
    if (res) snap = rewrite((_res$params = res.params) !== null && _res$params !== void 0 ? _res$params : res);
    return apply(snap);
  }, s => s); // reduce overrides into a single function

  let applyOverrides = overrides.reduceRight((apply, {
    include,
    exclude,
    ...opts
  }) => snap => {
    if ((0, _utils.snapshotMatches)(snap, include, exclude)) Object.assign(snap, opts);
    return apply(snap);
  }, s => s); // sort and reduce snapshots with overrides

  return [...snapshots].sort().reduce((snapshots, snap) => {
    snap = (0, _utils.withDefaults)(applyRewrites(snap), {
      host
    });
    return (0, _utils.snapshotMatches)(snap, include, exclude) ? snapshots.concat(applyOverrides(snap)) : snapshots;
  }, []);
} // Serves a static directory and returns a list of snapshots.


async function loadStaticSnapshots(dir, config) {
  let {
    default: globby
  } = await Promise.resolve().then(() => _interopRequireWildcard(require('globby'))); // gather paths with globby, which only accepts string patterns

  let isStr = s => typeof s === 'string';

  let strOr = (a, b) => a.length && a.every(isStr) ? a : b;

  let files = strOr([].concat(config.include || []), '**/*.html');
  let ignore = strOr([].concat(config.exclude || []), []);
  let paths = await globby(files, {
    cwd: dir,
    ignore
  }); // map snapshots from paths and config

  return mapStaticSnapshots(paths, config);
}