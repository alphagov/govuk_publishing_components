(function() {
  (function (exports) {
    'use strict';

    const process = (typeof globalThis !== "undefined" && globalThis.process) || {};
    process.env = process.env || {};
    process.env.__PERCY_BROWSERIFIED__ = true;

    // Returns a mostly random uid.
    function uid() {
      return `_${Math.random().toString(36).substr(2, 9)}`;
    }

    // Marks elements that are to be serialized later with a data attribute.
    function prepareDOM(dom) {
      for (let elem of dom.querySelectorAll('input, textarea, select, iframe, canvas, video, style')) {
        if (!elem.getAttribute('data-percy-element-id')) {
          elem.setAttribute('data-percy-element-id', uid());
        }
      }
      return dom;
    }

    // Translates JavaScript properties of inputs into DOM attributes.
    function serializeInputElements(_ref) {
      let {
        dom,
        clone
      } = _ref;
      for (let elem of dom.querySelectorAll('input, textarea, select')) {
        let inputId = elem.getAttribute('data-percy-element-id');
        let cloneEl = clone.querySelector(`[data-percy-element-id="${inputId}"]`);
        switch (elem.type) {
          case 'checkbox':
          case 'radio':
            if (elem.checked) {
              cloneEl.setAttribute('checked', '');
            }
            break;
          case 'select-one':
            if (elem.selectedIndex !== -1) {
              cloneEl.options[elem.selectedIndex].setAttribute('selected', 'true');
            }
            break;
          case 'select-multiple':
            for (let option of elem.selectedOptions) {
              cloneEl.options[option.index].setAttribute('selected', 'true');
            }
            break;
          case 'textarea':
            cloneEl.innerHTML = elem.value;
            break;
          default:
            cloneEl.setAttribute('value', elem.value);
        }
      }
    }

    // Adds a `<base>` element to the serialized iframe's `<head>`. This is necessary when
    // embedded documents are serialized and their contents become root-relative.
    function setBaseURI(dom) {
      if (!new URL(dom.baseURI).hostname) return;
      let $base = document.createElement('base');
      $base.href = dom.baseURI;
      dom.querySelector('head').prepend($base);
    }

    // Recursively serializes iframe documents into srcdoc attributes.
    function serializeFrames(_ref) {
      let {
        dom,
        clone,
        warnings,
        resources,
        enableJavaScript
      } = _ref;
      for (let frame of dom.querySelectorAll('iframe')) {
        let percyElementId = frame.getAttribute('data-percy-element-id');
        let cloneEl = clone.querySelector(`[data-percy-element-id="${percyElementId}"]`);
        let builtWithJs = !frame.srcdoc && (!frame.src || frame.src.split(':')[0] === 'javascript');

        // delete frames within the head since they usually break pages when
        // rerendered and do not effect the visuals of a page
        if (clone.head.contains(cloneEl)) {
          cloneEl.remove();

          // if the frame document is accessible and not empty, we can serialize it
        } else if (frame.contentDocument && frame.contentDocument.documentElement) {
          // js is enabled and this frame was built with js, don't serialize it
          if (enableJavaScript && builtWithJs) continue;

          // the frame has yet to load and wasn't built with js, it is unsafe to serialize
          if (!builtWithJs && !frame.contentWindow.performance.timing.loadEventEnd) continue;

          // recersively serialize contents
          let serialized = serializeDOM({
            domTransformation: setBaseURI,
            dom: frame.contentDocument,
            enableJavaScript
          });

          // append serialized warnings and resources
          /* istanbul ignore next: warnings not implemented yet */
          for (let w of serialized.warnings) warnings.add(w);
          for (let r of serialized.resources) resources.add(r);

          // assign serialized html to srcdoc and remove src
          cloneEl.setAttribute('srcdoc', serialized.html);
          cloneEl.removeAttribute('src');

          // delete inaccessible frames built with js when js is disabled because they
          // break asset discovery by creating non-captured requests that hang
        } else if (!enableJavaScript && builtWithJs) {
          cloneEl.remove();
        }
      }
    }

    // Returns true if a stylesheet is a CSSOM-based stylesheet.
    function isCSSOM(styleSheet) {
      // no href, has a rulesheet, and has an owner node
      return !styleSheet.href && styleSheet.cssRules && styleSheet.ownerNode;
    }

    // Returns false if any stylesheet rules do not match between two stylesheets
    function styleSheetsMatch(sheetA, sheetB) {
      for (let i = 0; i < sheetA.cssRules.length; i++) {
        var _sheetB$cssRules$i;
        let ruleA = sheetA.cssRules[i].cssText;
        let ruleB = (_sheetB$cssRules$i = sheetB.cssRules[i]) === null || _sheetB$cssRules$i === void 0 ? void 0 : _sheetB$cssRules$i.cssText;
        if (ruleA !== ruleB) return false;
      }
      return true;
    }

    // Outputs in-memory CSSOM into their respective DOM nodes.
    function serializeCSSOM(_ref) {
      let {
        dom,
        clone
      } = _ref;
      for (let styleSheet of dom.styleSheets) {
        if (isCSSOM(styleSheet)) {
          let styleId = styleSheet.ownerNode.getAttribute('data-percy-element-id');
          let cloneOwnerNode = clone.querySelector(`[data-percy-element-id="${styleId}"]`);
          if (styleSheetsMatch(styleSheet, cloneOwnerNode.sheet)) continue;
          let style = clone.createElement('style');
          style.type = 'text/css';
          style.setAttribute('data-percy-element-id', styleId);
          style.setAttribute('data-percy-cssom-serialized', 'true');
          style.innerHTML = Array.from(styleSheet.cssRules).map(cssRule => cssRule.cssText).join('\n');
          cloneOwnerNode.parentNode.insertBefore(style, cloneOwnerNode.nextSibling);
          cloneOwnerNode.remove();
        }
      }
    }

    // Creates a resource object from an element's unique ID and data URL
    function resourceFromDataURL(uid, dataURL) {
      // split dataURL into desired parts
      let [data, content] = dataURL.split(',');
      let [, mimetype] = data.split(':');
      [mimetype] = mimetype.split(';');

      // build a URL for the serialized asset
      let [, ext] = mimetype.split('/');
      let path = `/__serialized__/${uid}.${ext}`;
      let url = new URL(path, document.URL).toString();

      // return the url, base64 content, and mimetype
      return {
        url,
        content,
        mimetype
      };
    }

    // Serialize in-memory canvas elements into images.
    function serializeCanvas(_ref) {
      let {
        dom,
        clone,
        resources
      } = _ref;
      for (let canvas of dom.querySelectorAll('canvas')) {
        // Note: the `.toDataURL` API requires WebGL canvas elements to use
        // `preserveDrawingBuffer: true`. This is because `.toDataURL` uses the
        // drawing buffer, which is cleared after each render for WebGL by default.
        let dataUrl = canvas.toDataURL();

        // skip empty canvases
        if (!dataUrl || dataUrl === 'data:,') continue;

        // get the element's percy id and create a resource for it
        let percyElementId = canvas.getAttribute('data-percy-element-id');
        let resource = resourceFromDataURL(percyElementId, dataUrl);
        resources.add(resource);

        // create an image element in the cloned dom
        let img = clone.createElement('img');
        // use a data attribute to avoid making a real request
        img.setAttribute('data-percy-serialized-attribute-src', resource.url);

        // copy canvas element attributes to the image element such as style, class,
        // or data attributes that may be targeted by CSS
        for (let {
          name,
          value
        } of canvas.attributes) {
          img.setAttribute(name, value);
        }

        // mark the image as serialized (can be targeted by CSS)
        img.setAttribute('data-percy-canvas-serialized', '');
        // set a default max width to account for canvases that might resize with JS
        img.style.maxWidth = img.style.maxWidth || '100%';

        // insert the image into the cloned DOM and remove the cloned canvas element
        let cloneEl = clone.querySelector(`[data-percy-element-id=${percyElementId}]`);
        cloneEl.parentElement.insertBefore(img, cloneEl);
        cloneEl.remove();
      }
    }

    // Captures the current frame of videos and sets the poster image
    function serializeVideos(_ref) {
      let {
        dom,
        clone,
        resources
      } = _ref;
      for (let video of dom.querySelectorAll('video')) {
        // if the video already has a poster image, no work for us to do
        if (video.getAttribute('poster')) continue;
        let videoId = video.getAttribute('data-percy-element-id');
        let cloneEl = clone.querySelector(`[data-percy-element-id="${videoId}"]`);
        let canvas = document.createElement('canvas');
        let width = canvas.width = video.videoWidth;
        let height = canvas.height = video.videoHeight;
        let dataUrl;
        canvas.getContext('2d').drawImage(video, 0, 0, width, height);
        try {
          dataUrl = canvas.toDataURL();
        } catch {}

        // if the canvas produces a blank image, skip
        if (!dataUrl || dataUrl === 'data:,') continue;

        // create a resource from the serialized data url
        let resource = resourceFromDataURL(videoId, dataUrl);
        resources.add(resource);

        // use a data attribute to avoid making a real request
        cloneEl.setAttribute('data-percy-serialized-attribute-poster', resource.url);
      }
    }

    // Returns a copy or new doctype for a document.
    function doctype(dom) {
      let {
        name = 'html',
        publicId = '',
        systemId = ''
      } = (dom === null || dom === void 0 ? void 0 : dom.doctype) ?? {};
      let deprecated = '';
      if (publicId && systemId) {
        deprecated = ` PUBLIC "${publicId}" "${systemId}"`;
      } else if (publicId) {
        deprecated = ` PUBLIC "${publicId}"`;
      } else if (systemId) {
        deprecated = ` SYSTEM "${systemId}"`;
      }
      return `<!DOCTYPE ${name}${deprecated}>`;
    }

    // Serializes and returns the cloned DOM as an HTML string
    function serializeHTML(ctx) {
      let html = ctx.clone.documentElement.outerHTML;
      // replace serialized data attributes with real attributes
      html = html.replace(/ data-percy-serialized-attribute-(\w+?)=/ig, ' $1=');
      // include the doctype with the html string
      return doctype(ctx.dom) + html;
    }

    // Serializes a document and returns the resulting DOM string.
    function serializeDOM(options) {
      let {
        dom = document,
        // allow snake_case or camelCase
        enableJavaScript = options === null || options === void 0 ? void 0 : options.enable_javascript,
        domTransformation = options === null || options === void 0 ? void 0 : options.dom_transformation,
        stringifyResponse = options === null || options === void 0 ? void 0 : options.stringify_response
      } = options || {};

      // keep certain records throughout serialization
      let ctx = {
        resources: new Set(),
        warnings: new Set(),
        enableJavaScript
      };
      ctx.dom = prepareDOM(dom);
      ctx.clone = ctx.dom.cloneNode(true);
      serializeInputElements(ctx);
      serializeFrames(ctx);
      serializeVideos(ctx);
      if (!enableJavaScript) {
        serializeCSSOM(ctx);
        serializeCanvas(ctx);
      }
      if (domTransformation) {
        try {
          domTransformation(ctx.clone.documentElement);
        } catch (err) {
          console.error('Could not transform the dom:', err.message);
        }
      }
      let result = {
        html: serializeHTML(ctx),
        warnings: Array.from(ctx.warnings),
        resources: Array.from(ctx.resources)
      };
      return stringifyResponse ? JSON.stringify(result) : result;
    }

    exports["default"] = serializeDOM;
    exports.serialize = serializeDOM;
    exports.serializeDOM = serializeDOM;

    Object.defineProperty(exports, '__esModule', { value: true });

  })(this.PercyDOM = this.PercyDOM || {});
}).call(window);

if (typeof define === "function" && define.amd) {
  define("@percy/dom", [], () => window.PercyDOM);
} else if (typeof module === "object" && module.exports) {
  module.exports = window.PercyDOM;
}
