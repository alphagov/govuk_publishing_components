/* global accessibleAutocomplete, fetch */
//= require accessible-autocomplete/dist/accessible-autocomplete.min.js
window.GOVUK = window.GOVUK || {};
window.GOVUK.Modules = window.GOVUK.Modules || {};

(function (Modules) {
  class SearchWithAutocomplete {
    constructor ($module) {
      this.$module = $module

      this.$originalInput = this.$module.querySelector('input')
      this.$inputWrapper = this.$module.querySelector('.gem-c-search__input-wrapper')

      this.source = this.$module.getAttribute('data-source')
      this.sourceKey = this.$module.getAttribute('data-source-key')
    }

    init () {
      if (!this.source || !this.sourceKey) {
        console.warn('search-with-autocomplete: No source or source-key provided; skipping init')
        return
      }

      const configOptions = {
        element: this.$inputWrapper,
        id: this.$originalInput.id,
        name: this.$originalInput.name,
        inputClasses: this.$originalInput.classList,
        defaultValue: this.$originalInput.value,
        source: this.getResults,
      }
      accessibleAutocomplete(configOptions)

      // The accessible-autocomplete component is meant to generate a new input element rather than enhancing an existing one, so we need to do some cleanup here.
      const autocompleteInput = this.$inputWrapper.querySelector('.autocomplete__input')
      // Ensure the new input element generated by accessible-autocomplete has the correct type
      autocompleteInput.setAttribute("type", "search")
      // Remove the original input from the DOM
      this.$originalInput.parentNode.removeChild(this.$originalInput)
    }

    getResults = (query, populateResults) => {
      fetch(`${this.source}${query}`)
        .then(response => response.json())
        .then(data => data[this.sourceKey])
        .then(results => {
          populateResults(results)
        })
    }
  }

  Modules.SearchWithAutocomplete = SearchWithAutocomplete
})(window.GOVUK.Modules)
