/* global accessibleAutocomplete, fetch */
//= require accessible-autocomplete/dist/accessible-autocomplete.min.js

window.GOVUK = window.GOVUK || {}
window.GOVUK.Modules = window.GOVUK.Modules || {};

(function (Modules) {
  class SearchWithAutocomplete {
    constructor ($module) {
      this.$module = $module

      this.$originalInput = this.$module.querySelector('input')
      this.$inputWrapper = this.$module.querySelector('.gem-c-search__input-wrapper')
      this.$form = this.$module.closest('form')

      this.source = this.$module.getAttribute('data-source')
      this.sourceKey = this.$module.getAttribute('data-source-key')
    }

    init () {
      if (!this.source || !this.sourceKey) {
        console.warn('search-with-autocomplete: No source/sourceKey provided')
        return
      }

      const configOptions = {
        element: this.$inputWrapper,
        id: this.$originalInput.id,
        name: this.$originalInput.name,
        inputClasses: this.$originalInput.classList,
        defaultValue: this.$originalInput.value,
        confirmOnBlur: false,
        showNoOptionsFound: false,
        source: this.getResults.bind(this),
        onConfirm: this.submitContainingForm.bind(this),
        templates: {
          suggestion: this.constructSuggestionHTMLString.bind(this)
        }
      }

      accessibleAutocomplete(configOptions)

      // The accessible-autocomplete component is meant to generate a new input element rather than enhancing an existing one, so we need to do some cleanup here.
      const autocompleteInput = this.$inputWrapper.querySelector('.autocomplete__input')
      // Ensure the new input element generated by accessible-autocomplete has the correct type
      autocompleteInput.setAttribute('type', 'search')
      // Remove the original input from the DOM
      this.$originalInput.parentNode.removeChild(this.$originalInput)
    }

    // Callback used by accessible-autocomplete to generate the HTML for each suggestion
    constructSuggestionHTMLString (result) {
      // We should be able to assume that data coming back from the Autocomplete API is safe to
      // render as HTML. However, this is a final line of defence to prevent XSS.
      const sanitizedResult = result.replace(/[&<>"']/g, '')
      const inputValue = this.$inputWrapper.querySelector('input').value.toLowerCase()

      const index = sanitizedResult.toLowerCase().indexOf(inputValue)

      let html = sanitizedResult
      if (index !== -1) {
        const before = sanitizedResult.slice(0, index)
        const match = sanitizedResult.slice(index, index + inputValue.length)
        const after = sanitizedResult.slice(index + inputValue.length)

        html = `${before}<mark>${match}</mark>${after}`
      }

      return `
        <div class="autocomplete__option-wrapper">
          <span class="autocomplete__suggestion-icon"></span>
          <span class="autocomplete__suggestion-text">${html}</span>
        </div>
      `
    }

    getResults (query, populateResults) {
      const url = new URL(this.source)
      url.searchParams.set('q', query)
      fetch(url)
        .then(response => response.json())
        .then(data => data[this.sourceKey])
        .then(populateResults)
        .catch(() => { populateResults([]) })
    }

    submitContainingForm () {
      if (this.$form) {
        this.$form.submit()
      }
    }
  }

  Modules.SearchWithAutocomplete = SearchWithAutocomplete
})(window.GOVUK.Modules)
